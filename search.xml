<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo上传pdf文件</title>
    <url>/2024/02/28/Hexo%E4%B8%8A%E4%BC%A0pdf%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<hr>
<p>利用Hexo上传本地PDF文件</p>
<span id="more"></span>

<p>参考：<a href="https://blog.csdn.net/qq_43827595/article/details/104574959">【如何在网页中实现pdf在线预览】10分钟学会如何利用Hexo博客上传本地pdf文件并在线预览pdf_hexo中可以上传一个pdf文件吗?-CSDN博客</a></p>
<ol>
<li><p>在搭建好的hexo博客的根目录的source文件夹下新建一个文件夹，如file（用来存pdf文件），其实只要求pdf文件夹在source文件夹内</p>
</li>
<li><p><code>hexo g</code></p>
</li>
<li><p>可以看到生成的pdf链接，如：</p>
<p><img src="/2024/02/28/Hexo%E4%B8%8A%E4%BC%A0pdf%E6%96%87%E4%BB%B6/image-20240228213400656.png" alt="image-20240228213400656"></p>
</li>
<li><p>用<code>hexo d</code>把静态博客部署到远端后，用网址<code>博客域名/pdf/MySQL-基础篇.pdf</code>就可以访问这个pdf文件了</p>
</li>
</ol>
<p>同样的道理把html文件、jpg文件放到pdf文件夹里也可以生成网页链接</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>IO流</title>
    <url>/2024/02/05/IO%E6%B5%81/</url>
    <content><![CDATA[<hr>
<p>Java IO流</p>
<span id="more"></span>

<h2 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h2><ol>
<li><p>按照 <strong>流的方向</strong> 进行分类：</p>
<p>以<strong>内存</strong>作为参照物：</p>
<ul>
<li>往内存中去：叫做**输入(Input)<strong>。或者叫做</strong>读(Read)**。</li>
<li>从内存中出来：叫做**输出(Output)<strong>。或者叫做</strong>写(Write)**。</li>
</ul>
</li>
<li><p>按照<strong>读取数据方式</strong>不同进行分类：</p>
<ul>
<li><p>按照 <strong><code>字节</code></strong> 的方式读取数据，一次读取1个字节byte，等同于一次读取8个二进制位。</p>
<p>这种流是<strong>万能</strong>的，什么类型的文件都可以读取。包括：**<code>文本文件，图片，声音文件，视频文件</code>** 等…</p>
</li>
<li><p>按照 <strong><code>字符</code></strong> 的方式读取数据的，一次读取一个字符。</p>
<p>这种流是为了方便读取 <strong><code>普通文本文件</code></strong> 而存在的，这种流不能读取：图片、声音、视频等文件。只能读取 **<code>纯文本文件</code>**，连word文件都无法读取。</p>
<p><em>Tip：纯文本文件，不单单是.txt文件，还包括 <strong>.java、.ini、.py</strong> 。总之只要 <strong><code>能用记事本打开</code></strong> 的文件都是普通文本文件。</em></p>
</li>
</ul>
</li>
</ol>
<h2 id="常用文件操作"><a href="#常用文件操作" class="headerlink" title="常用文件操作"></a>常用文件操作</h2><p>一个File对象有可能对应的是<strong>目录</strong>，也可能是<strong>文件</strong>。</p>
<p><strong>File只是一个路径名的抽象表示形式，是一个对象，只有执行了createNewFile方法，才会真正的在磁盘创建文件</strong></p>
<h3 id="创建文件对象"><a href="#创建文件对象" class="headerlink" title="创建文件对象"></a>创建文件对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(String pathname) <span class="comment">//根据路径创建一个File对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(File parent, String child) <span class="comment">//根据父目录文件+子路径创建</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(String parent, String child) <span class="comment">//根据父目录+子路径创建</span></span><br></pre></td></tr></table></figure>

<h3 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>boolean delete()</td>
<td>删除文件&#x2F;<strong>空</strong>文件夹</td>
</tr>
<tr>
<td>boolean exists()</td>
<td>判断文件&#x2F;文件夹是否存在</td>
</tr>
<tr>
<td>File getAbsoluteFile()</td>
<td>获取文件&#x2F;文件夹的绝对路径（返回值：File）</td>
</tr>
<tr>
<td>String getAbsolutePath()</td>
<td>获取绝对路径（返回值：String）</td>
</tr>
<tr>
<td>String getName()</td>
<td>获得文件&#x2F;文件夹名字</td>
</tr>
<tr>
<td>String getParent()</td>
<td>获取文件&#x2F;文件夹的父级目录</td>
</tr>
<tr>
<td>File getParentFile()</td>
<td>获取文件&#x2F;文件夹的父文件&#x2F;文件夹（返回值：File）</td>
</tr>
<tr>
<td>String getPath()</td>
<td>获取文件&#x2F;文件夹的路径</td>
</tr>
<tr>
<td>boolean isDirectory()</td>
<td>判断该文件&#x2F;文件夹是不是文件夹</td>
</tr>
<tr>
<td>isFile()</td>
<td>判断该文件&#x2F;文件夹是不是文件</td>
</tr>
<tr>
<td><strong>long length()</strong></td>
<td><strong>获取文件大小；获取文件夹里面的文件个数</strong></td>
</tr>
<tr>
<td>String[] list()</td>
<td>获取文件夹的文件名字以String[]返回</td>
</tr>
<tr>
<td>File[] listFiles()</td>
<td>获取文件夹的文件名字以File[]返回</td>
</tr>
</tbody></table>
<p>创建文件和文件夹：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>createNewFile</td>
<td>创建文件</td>
</tr>
<tr>
<td>boolean mkdir()</td>
<td>创建文件&#x2F;文件夹</td>
</tr>
<tr>
<td>boolean mkdirs()</td>
<td>创建多重文件夹</td>
</tr>
</tbody></table>
<h2 id="IO流常用类"><a href="#IO流常用类" class="headerlink" title="IO流常用类"></a>IO流常用类</h2><h3 id="IO流体系"><a href="#IO流体系" class="headerlink" title="IO流体系"></a>IO流体系</h3><table>
<thead>
<tr>
<th>（抽象基类）</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody></table>
<p><img src="/2024/02/05/IO%E6%B5%81/image-20240206120106348.png" alt="image-20240206120106348"></p>
<h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><p>InputStream抽象类是所有字节输入流类的超类</p>
<p>InputStream常用子类：</p>
<ul>
<li>FileInputStream：文件输入流</li>
<li>BufferedInputStream：缓冲字节输入流</li>
<li>ObjectInputStream：对象字节输入流</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>int read()</td>
<td>读取一个字节，返回值为该字节<strong>ASCII码</strong>；读到文件末尾返回-1</td>
</tr>
<tr>
<td>int read(byte[] b)</td>
<td>读b数组长度的字节到b数组中，返回值为读到的字节个数；读到文件末尾返回-1</td>
</tr>
<tr>
<td>int read(byte[] b, int off, int len)</td>
<td>从b素组off位置读len长度的字节到b数组中，返回值为读到的字节个数；读到文件末尾返回-1</td>
</tr>
<tr>
<td>int available()</td>
<td>返回文件有效的字节数</td>
</tr>
<tr>
<td>long skip(long n)</td>
<td>跳过n个字节</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭文件输入流</td>
</tr>
</tbody></table>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;chapter23/src/tempfile3&quot;</span>);</span><br><span class="line">            <span class="comment">// 开始读，采用byte数组，一次读取多个字节。最多读取“数组.length”个字节。</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];<span class="comment">// 准备一个4个长度的byte数组，一次最多读取4个字节。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">readCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 这个方法的返回值是：读取到的字节数量。（不是字节本身）;1个字节都没有读取到返回-1(文件读到末尾)</span></span><br><span class="line">            <span class="keyword">while</span>((readCount = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            	<span class="comment">// 不应该全部都转换，应该是读取了多少个字节，转换多少个。</span></span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, readCount));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        	<span class="comment">// 在finally语句块当中确保流一定关闭。</span></span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;<span class="comment">// 避免空指针异常！</span></span><br><span class="line">            	<span class="comment">// 关闭流的前提是：流不是空。流是null的时候没必要关闭。</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamTest05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;tempfile&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;总字节数量：&quot;</span> + fis.available());</span><br><span class="line">            <span class="comment">// 读1个字节</span></span><br><span class="line">            <span class="comment">//int readByte = fis.read();</span></span><br><span class="line">            <span class="comment">// 还剩下可以读的字节数量是：5</span></span><br><span class="line">            <span class="comment">//System.out.println(&quot;剩下多少个字节没有读：&quot; + fis.available());</span></span><br><span class="line">            <span class="comment">// 这个方法有什么用？</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[fis.available()]; <span class="comment">// 这种方式不太适合太大的文件，因为byte[]数组不能太大。</span></span><br><span class="line">            <span class="comment">// 不需要循环了。</span></span><br><span class="line">            <span class="comment">// 直接读一次就行了。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">readCount</span> <span class="operator">=</span> fis.read(bytes); <span class="comment">// 6</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes)); <span class="comment">// abcdef</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// skip跳过几个字节不读取，这个方法也可能以后会用！</span></span><br><span class="line">            fis.skip(<span class="number">3</span>);</span><br><span class="line">            System.out.println(fis.read()); <span class="comment">//100</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><p><strong>构造方法：</strong></p>
<table>
<thead>
<tr>
<th>构造方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>FileOutputStream(String name)</td>
<td>name为文件路径</td>
</tr>
<tr>
<td>FileOutputStream(String name, boolean append)</td>
<td>name为文件路径，append为true表示在文件末尾追加；为false表示清空文件内容，重新写入</td>
</tr>
<tr>
<td>FileOutputStream(File file)</td>
<td></td>
</tr>
<tr>
<td>FileOutputStream(File file, boolean append)</td>
<td>append为true表示在文件末尾追加；为false表示清空文件内容，重新写入</td>
</tr>
</tbody></table>
<p><strong>方法：</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int b)</td>
<td>将指定字节写入文件中</td>
</tr>
<tr>
<td>void write(byte[] b)</td>
<td>将b.length个字节写入文件中</td>
</tr>
<tr>
<td>void write(byte[] b, int off, int len)</td>
<td>将b素组off位置开始，len长度的字节写入文件中</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新此输出流并强制写出所有缓冲的输出字节</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭文件输出流</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// myfile文件不存在的时候会自动新建！</span></span><br><span class="line">            <span class="comment">// 这种方式谨慎使用，这种方式会先将原文件清空，然后重新写入。</span></span><br><span class="line">            <span class="comment">//fos = new FileOutputStream(&quot;myfile&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以追加的方式在文件末尾写入。不会清空原文件内容。</span></span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;tempfile3&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 开始写。</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>&#125;;</span><br><span class="line">            <span class="comment">// 将byte数组全部写出！</span></span><br><span class="line">            fos.write(bytes); <span class="comment">// abcd</span></span><br><span class="line">            <span class="comment">// 将byte数组的一部分写出！</span></span><br><span class="line">            fos.write(bytes, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 再写出ab</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;我是一个中国人，我骄傲！！！&quot;</span>;</span><br><span class="line">            <span class="comment">// 将字符串转换成byte数组。</span></span><br><span class="line">            <span class="type">byte</span>[] bs = s.getBytes();</span><br><span class="line">            <span class="comment">// 写</span></span><br><span class="line">            fos.write(bs);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写完之后，最后一定要刷新</span></span><br><span class="line">            fos.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p><strong>构造方法：</strong></p>
<table>
<thead>
<tr>
<th>构造方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>FileReader(String fileName)</td>
<td>name为文件路径</td>
</tr>
<tr>
<td>FileReader(File file)</td>
<td></td>
</tr>
</tbody></table>
<p><strong>方法：</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>int read()</td>
<td>读取一个字符，返回值为该字符ASCII码；读到文件末尾返回-1</td>
</tr>
<tr>
<td>int read(char[] c)</td>
<td>读c数组长度的字节到c数组中，返回值为读到的字符个数；读到文件末尾返回-1</td>
</tr>
<tr>
<td>int read(char[] c, int off, int len)</td>
<td>从c素组off位置读len长度的字符到c数组中，返回值为读到的字符个数；读到文件末尾返回-1</td>
</tr>
<tr>
<td>long skip(long n)</td>
<td>跳过n个字符</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭文件输入流</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建文件字符输入流</span></span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;tempfile&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 开始读</span></span><br><span class="line">            <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">4</span>]; <span class="comment">// 一次读取4个字符</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">readCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((readCount = reader.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(chars,<span class="number">0</span>,readCount));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h3><p><strong>构造方法</strong></p>
<table>
<thead>
<tr>
<th>构造方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>FileWriter(String fileName)</td>
<td>name为文件路径</td>
</tr>
<tr>
<td>FileWriter(String fileName, boolean append)</td>
<td>name为文件路径，append为true表示在文件末尾追加；为false表示清空文件内容，重新写入</td>
</tr>
<tr>
<td>FileWriter(File file)</td>
<td></td>
</tr>
<tr>
<td>FileWriter(File file, boolean append)</td>
<td>append为true表示在文件末尾追加；为false表示清空文件内容，重新写入</td>
</tr>
</tbody></table>
<p><strong>方法</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int c)</td>
<td>将指定字符写入文件中</td>
</tr>
<tr>
<td>void write(char[] c)</td>
<td>将c.length个字符写入文件中</td>
</tr>
<tr>
<td>void write(char[] c, int off, int len)</td>
<td>将c素组off位置开始，len长度的字符写入文件中</td>
</tr>
<tr>
<td>void write(String str)</td>
<td>将字符串写入文件中</td>
</tr>
<tr>
<td>void write(String str, int off, int len)</td>
<td>从字符串off位置开始截取len长度的字符串写入文件</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新此输出流并强制写出所有缓冲的输出字符</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭文件输出流</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriterTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建文件字符输出流对象</span></span><br><span class="line">            <span class="comment">//out = new FileWriter(&quot;file&quot;);</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;file&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始写。</span></span><br><span class="line">            <span class="type">char</span>[] chars = &#123;<span class="string">&#x27;我&#x27;</span>,<span class="string">&#x27;是&#x27;</span>,<span class="string">&#x27;中&#x27;</span>,<span class="string">&#x27;国&#x27;</span>,<span class="string">&#x27;人&#x27;</span>&#125;;</span><br><span class="line">            out.write(chars);</span><br><span class="line">            out.write(chars, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            out.write(<span class="string">&quot;我是一名java软件工程师！&quot;</span>);</span><br><span class="line">            <span class="comment">// 写出一个换行符。</span></span><br><span class="line">            out.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            out.write(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 刷新</span></span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>Tip：对于FileWriter , 一定要关闭流，或者 flush 才能真正的把数据写入到文件</em></p>
<h3 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h3><p>节点流：可以从一个特定的数据源读写数据，如FileReader、FileWriter</p>
<p>处理流：也叫包装流，连接在已存在的流之上，为程序提供更强大的读写功能，如BufferedReader、BufferedWriter</p>
<p><img src="/2024/02/05/IO%E6%B5%81/image-20240207161653138.png" alt="image-20240207161653138"></p>
<p><em>处理流对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连。</em></p>
<p>关闭处理流时，只需要关闭外层流即可</p>
<h3 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h3><p><strong>构造方法</strong></p>
<table>
<thead>
<tr>
<th>构造方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>BufferedReader(Reader in)</td>
<td>in为reader对象（可以是reader的实现类）</td>
</tr>
</tbody></table>
<p><strong>方法</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>int read()</td>
<td>读取一个字符，返回值为该字符ASCII码；读到文件末尾返回-1</td>
</tr>
<tr>
<td>int read(char[] c)</td>
<td>读c数组长度的字节到c数组中，返回值为读到的字符个数；读到文件末尾返回-1</td>
</tr>
<tr>
<td>String readLine()</td>
<td>读取文件一行</td>
</tr>
<tr>
<td>long skip(long n)</td>
<td>跳过n个字符</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭文件输入流</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;Copy02.java&quot;</span>);</span><br><span class="line">        <span class="comment">// 当一个流的构造方法中需要一个流的时候，这个被传进来的流叫做：节点流。</span></span><br><span class="line">        <span class="comment">// 外部负责包装的这个流，叫做：包装流，还有一个名字叫做：处理流。</span></span><br><span class="line">        <span class="comment">// 像当前这个程序来说：FileReader就是一个节点流。BufferedReader就是包装流/处理流。</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// br.readLine()方法读取一个文本行，但不带换行符。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((s = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.print(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭流</span></span><br><span class="line">        <span class="comment">// 对于包装流来说，只需要关闭最外层流就行，里面的节点流会自动关闭。（可以看源代码。）</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h3><p><strong>构造方法</strong></p>
<table>
<thead>
<tr>
<th>构造方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>BufferedWriter(Writer out)</td>
<td>out为Writer对象（可以是reader的实现类）</td>
</tr>
</tbody></table>
<p><strong>方法</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int c)</td>
<td>将指定字符写入文件中</td>
</tr>
<tr>
<td>void write(char[] c, int off, int len)</td>
<td>将c素组off位置开始，len长度的字符写入文件中</td>
</tr>
<tr>
<td>void write(String str, int off, int len)</td>
<td>从字符串off位置开始截取len长度的字符串写入文件</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新此输出流并强制写出所有缓冲的输出字符</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭文件输出流</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">// 带有缓冲区的字符输出流</span></span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;copy&quot;</span>, <span class="literal">true</span>)));</span><br><span class="line">    <span class="comment">// 开始写。</span></span><br><span class="line">    out.write(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;hello kitty!&quot;</span>);</span><br><span class="line">    <span class="comment">// 刷新</span></span><br><span class="line">    out.flush();</span><br><span class="line">    <span class="comment">// 关闭最外层</span></span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>序列化就是在保存数据时，保存数据的值和数据类型</p>
<p>反序列化时在恢复数据时，恢复数据的值和数据类型</p>
<p>需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：</p>
<ul>
<li>Serializable：是一个标记接口，没有方法</li>
<li>Externalizable：该接口有方法需要实现，建议用上面的方法</li>
</ul>
<p>Serializable这个标志接口是给java虚拟机参考的，java虚拟机看到这个接口之后，会为该类自动生成一个序列化版本号。</p>
<p>这种自动生成的序列化版本号缺点是：一旦代码确定之后，<strong>不能进行后续的修改</strong>，因为只要修改，必然会重新编译，此时会生成全新的序列化版本号，这个时候java虚拟机会认为这是一个全新的类。</p>
<p>所以凡是一个类实现了Serializable接口，建议给该类<strong>提供一个固定不变的序列化版本号</strong>。<br>这样，以后这个类即使代码修改了，但是版本号不变，java虚拟机会认为是同一个类。</p>
<p><img src="/2024/02/05/IO%E6%B5%81/image-20240208122432984.png" alt="image-20240208122432984"></p>
<h3 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h3><p>序列化对象</p>
<p><strong>构造方法</strong></p>
<table>
<thead>
<tr>
<th>构造方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ObjectOutputStream(OutputStream out)</td>
<td>out为OutputStream对象</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectOutStream_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//序列化后，保存的文件格式，不是存文本，而是按照他的格式来保存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\data.dat&quot;</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath));</span><br><span class="line">        <span class="comment">//序列化数据到 e:\data.dat</span></span><br><span class="line">        oos.writeInt(<span class="number">100</span>);<span class="comment">// int -&gt; Integer (实现了 Serializable)</span></span><br><span class="line">        oos.writeBoolean(<span class="literal">true</span>);<span class="comment">// boolean -&gt; Boolean (实现了 Serializable)</span></span><br><span class="line">        oos.writeChar(<span class="string">&#x27;a&#x27;</span>);<span class="comment">// char -&gt; Character (实现了 Serializable)</span></span><br><span class="line">        oos.writeDouble(<span class="number">9.5</span>);<span class="comment">// double -&gt; Double (实现了 Serializable)</span></span><br><span class="line">        oos.writeUTF(<span class="string">&quot;韩顺平教育&quot;</span>);<span class="comment">//String</span></span><br><span class="line">        <span class="comment">//保存一个 dog 对象</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺财&quot;</span>, <span class="number">10</span>, <span class="string">&quot;日本&quot;</span>, <span class="string">&quot;白色&quot;</span>));</span><br><span class="line">        oos.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;数据保存完毕(序列化形式)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h3><p>反序列化对象</p>
<p><strong>构造方法</strong></p>
<table>
<thead>
<tr>
<th>构造方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ObjectInputStream(InputStream in)</td>
<td>in为InputStream对象</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建流对象</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\data.dat&quot;</span>));</span><br><span class="line"><span class="comment">// 2.读取， 注意顺序</span></span><br><span class="line">System.out.println(ois.readInt());</span><br><span class="line">System.out.println(ois.readBoolean());</span><br><span class="line">System.out.println(ois.readChar());</span><br><span class="line">System.out.println(ois.readDouble());</span><br><span class="line">System.out.println(ois.readUTF());</span><br><span class="line">System.out.println(ois.readObject());</span><br><span class="line">System.out.println(ois.readObject());</span><br><span class="line">System.out.println(ois.readObject());</span><br><span class="line"><span class="comment">// 3.关闭</span></span><br><span class="line">ois.close();</span><br><span class="line">System.out.println(<span class="string">&quot;以反序列化的方式读取(恢复)ok~&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><p>当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题</p>
<p>Reader的子类，可以将InputStream（字节流）包装成Reader（字符流）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将字节流 FileInputStream 转成字符流 InputStreamReader, 指定编码 gbk/utf-8</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.txt&quot;</span>;</span><br><span class="line">        <span class="comment">//1. 把 FileInputStream 转成 InputStreamReader</span></span><br><span class="line">        <span class="comment">//2. 指定编码 gbk</span></span><br><span class="line">        <span class="comment">//InputStreamReader isr = new InputStreamReader(new FileInputStream(filePath), &quot;gbk&quot;);</span></span><br><span class="line">        <span class="comment">//3. 把 InputStreamReader 传入 BufferedReader</span></span><br><span class="line">        <span class="comment">//BufferedReader br = new BufferedReader(isr);</span></span><br><span class="line">        <span class="comment">//将 2 和 3 合在一起</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath), <span class="string">&quot;gbk&quot;</span>));</span><br><span class="line">        <span class="comment">//4. 读取     </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;读取内容=&quot;</span> + s);</span><br><span class="line">        <span class="comment">//5. 关闭外层流</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h3><p>将OutputStream（字节流）转换成Writer（字符流）</p>
<h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h3><p>java.io.PrintStream：标准的字节输出流。默认输出到控制台。</p>
<p><strong>构造方法</strong></p>
<table>
<thead>
<tr>
<th>构造方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>PrintStream(File file)</td>
<td></td>
</tr>
<tr>
<td>PrintStream(OutputStream out)</td>
<td></td>
</tr>
<tr>
<td>PrintStream(String fileName)</td>
<td>fileName文件地址</td>
</tr>
</tbody></table>
<p><strong>方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>println(参数类型不定 x)</td>
<td>输出x带换行</td>
</tr>
<tr>
<td>print(参数类型不定 x)</td>
<td>输出x不带换行</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新此输出流并强制写出所有缓冲的输出字符</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭流</td>
</tr>
</tbody></table>
<p><strong>改变流的输出方向：</strong>   <strong><code>System.setOut(PrintStream对象)</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 可以改变标准输出流的输出方向吗？ 可以// 标准输出流不再指向控制台，指向“log”文件。</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">printStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;log&quot;</span>));</span><br><span class="line">        <span class="comment">// 修改输出方向，将输出方向修改到&quot;log&quot;文件。</span></span><br><span class="line">        System.setOut(printStream);<span class="comment">// 修改输出方向</span></span><br><span class="line">        <span class="comment">// 再输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;hello kitty&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;hello zhangsan&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL基础</title>
    <url>/2024/02/15/MySQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<hr>
<p>MySqL基础部分，包括SQL，函数，约束，多表查询，事务</p>
<span id="more"></span>

<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="MySQL服务的启动停止"><a href="#MySQL服务的启动停止" class="headerlink" title="MySQL服务的启动停止"></a>MySQL服务的启动停止</h3><p>MySQL安装完成之后，在系统启动时，会自动启动MySQL服务，我们无需手动启动了。 当然，也可以手动的通过指令启动停止，以管理员身份运行cmd，进入命令行执行如下指令：</p>
<blockquote>
<p>net start mysql80 </p>
<p>net stop mysql80</p>
</blockquote>
<p>Tip：上述的 mysql80 是我们在安装MySQL时，默认指定的mysql的系统服务名，不是固定的，如果未改动，默认就是mysql80。</p>
<h3 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h3><p>方式一：使用mysql提供的客户端命令行工具<code>MySQL 8.0 Command Line Client</code></p>
<p>方式二：使用系统自带的命令行工具，cmd运行下面命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql  [-h 127.0.0.1]  [-P 3306]  -u root -p</span><br><span class="line">参数：</span><br><span class="line">    -h : MySQL服务所在的主机IP</span><br><span class="line">    -P : MySQL服务端口号， 默认3306</span><br><span class="line">    -u : MySQL数据库用户名</span><br><span class="line">    -p ： MySQL数据库用户名对应的密码</span><br><span class="line">    </span><br><span class="line">[]内为可选参数，如果需要连接远程的MySQL，需要加上这两个参数来指定远程主机IP、端口，如果连接本地的MySQL，则无需指定这两个参数。</span><br></pre></td></tr></table></figure>



<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p><strong>注释：</strong></p>
<ul>
<li><p>单行注释：</p>
<p>– 注释内容</p>
<p># 注释内容</p>
</li>
<li><p>多行注释：</p>
<p>&#x2F;* 注释内容 *&#x2F;</p>
</li>
</ul>
<h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h3><table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">全程</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DDL</td>
<td align="center">Data Definition Language</td>
<td align="center">数据<strong>定义</strong>语言，用来定义数据库对象(数据库，表，字段)</td>
</tr>
<tr>
<td align="center">DML</td>
<td align="center">Data Manipulation Language</td>
<td align="center">数据<strong>操作</strong>语言，用来对数据库表中的数据进行<strong>增删改</strong></td>
</tr>
<tr>
<td align="center">DQL</td>
<td align="center">Data Query Language</td>
<td align="center">数据<strong>查询</strong>语言，用来查询数据库中表的记录</td>
</tr>
<tr>
<td align="center">DCL</td>
<td align="center">Data Control Language</td>
<td align="center">数据控制语言，用来创建数据库用户、控制数据库的访问权限</td>
</tr>
</tbody></table>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><ol>
<li><p>查询所有数据库</p>
<blockquote>
<p>show databases;</p>
</blockquote>
</li>
<li><p>创建数据库</p>
<blockquote>
<p>create database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序规则 ] ;</p>
</blockquote>
</li>
<li><p>查询当前数据库</p>
<blockquote>
<p>select database();</p>
</blockquote>
</li>
<li><p>删除数据库</p>
<blockquote>
<p>drop database [ if exists ] 数据库名 ;</p>
</blockquote>
</li>
<li><p>切换数据库</p>
<blockquote>
<p>use 数据库名;</p>
</blockquote>
</li>
</ol>
<h4 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h4><h5 id="查询创建"><a href="#查询创建" class="headerlink" title="查询创建"></a>查询创建</h5><ol>
<li><p>查询挡墙数据库所有表</p>
<blockquote>
<p>show tables;</p>
</blockquote>
</li>
<li><p>查看指定表结构</p>
<blockquote>
<p>desc 表名;</p>
</blockquote>
</li>
<li><p>查询指定表的建表语句</p>
<blockquote>
<p>show create table 表名;</p>
</blockquote>
</li>
<li><p>创建表结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> CREATE TABLE  表名(</span><br><span class="line">    字段1  字段1类型 [ COMMENT  字段1注释 ],</span><br><span class="line">    字段2  字段2类型 [COMMENT  字段2注释 ],</span><br><span class="line">    字段3  字段3类型 [COMMENT  字段3注释 ],</span><br><span class="line">     ......</span><br><span class="line">    字段n  字段n类型 [COMMENT  字段n注释 ] </span><br><span class="line">) [ COMMENT  表注释 ] ;</span><br></pre></td></tr></table></figure>

<p>注意: […] 内为可选参数，最后一个字段后面没有逗号</p>
</li>
</ol>
<h5 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h5><ol>
<li><p>添加字段</p>
<p> ALTER TABLE 表名 ADD  字段名  类型 (长度)  [ COMMENT 注释 ]  [ 约束 ];</p>
</li>
<li><p>修改数据类型</p>
<p>ALTER TABLE 表名 MODIFY  字段名  新数据类型 (长度);</p>
</li>
<li><p>修改字段名和字段类型</p>
<p>ALTER TABLE 表名 CHANGE  旧字段名  新字段名  类型 (长度)  [ COMMENT 注释 ]  [ 约束 ];</p>
</li>
<li><p>删除字段</p>
<p> ALTER TABLE 表名 DROP  字段名;</p>
</li>
<li><p>修改表名</p>
<p>ALTER TABLE 表名 RENAME TO  新表名;</p>
</li>
</ol>
<h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><ol>
<li><p>删除表</p>
<p>DROP  TABLE [ IF  EXISTS ]  表名;</p>
</li>
<li><p>删除指定表，并重新创建表</p>
<p>TRUNCATE  TABLE 表名;</p>
<p>在删除表的时候，表中的全部数据也都会被删除。</p>
</li>
</ol>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><h4 id="添加数据（INSERT）"><a href="#添加数据（INSERT）" class="headerlink" title="添加数据（INSERT）"></a>添加数据（INSERT）</h4><ol>
<li><p>给指定字段添加数据</p>
<p>INSERT INTO 表名 (字段名1, 字段名2, …)  VALUES (值1, 值2, …);</p>
</li>
<li><p>给全部字段添加数据</p>
<p> INSERT INTO 表名 VALUES (值1, 值2, …);</p>
</li>
<li><p>批量添加数据</p>
<p> INSERT INTO 表名 (字段名1, 字段名2, …)  VALUES (值1, 值2, …), (值1, 值2, …), (值1, 值2, …) ;</p>
<p> INSERT INTO 表名 VALUES (值1, 值2, …), (值1, 值2, …), (值1, 值2, …) ;</p>
</li>
</ol>
<h4 id="修改数据（UPDATE）"><a href="#修改数据（UPDATE）" class="headerlink" title="修改数据（UPDATE）"></a>修改数据（UPDATE）</h4><p>UPDATE   表名   SET   字段名1 &#x3D; 值1 , 字段名2 &#x3D; 值2 , …. [ WHERE  条件 ] ;</p>
<p><em>Tip：修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。</em></p>
<h4 id="删除数据（DELETE）"><a href="#删除数据（DELETE）" class="headerlink" title="删除数据（DELETE）"></a>删除数据（DELETE）</h4><p>DELETE  FROM  表名  [ WHERE  条件 ] ;</p>
<p><em>DELETE也一样，如果没有条件，则会删除整张表的所有数据</em></p>
<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p>DQL查询语句，语法结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    字段列表</span><br><span class="line">FROM</span><br><span class="line">    表名列表</span><br><span class="line">WHERE</span><br><span class="line">    条件列表</span><br><span class="line">GROUP  BY</span><br><span class="line">    分组字段列表</span><br><span class="line">HAVING</span><br><span class="line">    分组后条件列表</span><br><span class="line">ORDER BY</span><br><span class="line">    排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">    分页参数</span><br></pre></td></tr></table></figure>

<h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><ol>
<li><p>查询多个字段</p>
<p>SELECT   字段1, 字段2, 字段3 …  FROM   表名 ;</p>
<p>SELECT  *  FROM   表名 ;</p>
<p>Tip： * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。</p>
</li>
<li><p>字段设置别名</p>
<p>SELECT   字段1  [ AS  别名1 ] , 字段2  [ AS  别名2 ]   …  FROM   表名;</p>
<p>SELECT   字段1  [ 别名1 ] , 字段2  [ 别名2 ]   …  FROM   表名;（即as可省略）</p>
</li>
<li><p>去除重复记录</p>
<p>SELECT  DISTINCT  字段列表  FROM   表名;</p>
</li>
</ol>
<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>SELECT  字段列表  FROM   表名   WHERE   条件列表 ;</p>
<p><strong>比较运算符</strong></p>
<table>
<thead>
<tr>
<th>比较运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td></td>
</tr>
<tr>
<td>&lt;</td>
<td></td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td></td>
</tr>
<tr>
<td>&#x3D;</td>
<td></td>
</tr>
<tr>
<td>&lt;&gt;或!&#x3D;</td>
<td>不等于</td>
</tr>
<tr>
<td>BETWEEN AND</td>
<td>在某个范围之内</td>
</tr>
<tr>
<td>IN( )</td>
<td>在in之后的列表中的值，多选一</td>
</tr>
<tr>
<td>LIKE 占位符</td>
<td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td>
</tr>
<tr>
<td>IS NULL</td>
<td>是NULL</td>
</tr>
</tbody></table>
<p><strong>逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>AND &#x2F; &amp;&amp;</td>
<td></td>
</tr>
<tr>
<td>OR  &#x2F; ||</td>
<td></td>
</tr>
<tr>
<td>NOT &#x2F; !</td>
<td></td>
</tr>
</tbody></table>
<h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p>SELECT  聚合函数(字段列表)  FROM   表名 ;</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>count</td>
<td>统计数量</td>
</tr>
<tr>
<td>max</td>
<td>最大值</td>
</tr>
<tr>
<td>min</td>
<td>最小值</td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
</tr>
<tr>
<td>sum</td>
<td>求和</td>
</tr>
</tbody></table>
<p><em>注意 : NULL值是不参与所有聚合函数运算的。</em></p>
<h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p> SELECT  字段列表  FROM   表名  [ WHERE   条件 ]  GROUP   BY  分组字段名  [ HAVING  分组 后过滤条件 ];</p>
<p><strong>Tip：分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。</strong></p>
<p><strong>执行顺序: where &gt; 聚合函数 &gt; having 。</strong></p>
<h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><p> SELECT  字段列表  FROM   表名  ORDER  BY  字段1  排序方式1 , 字段2  排序方式2 ;</p>
<ul>
<li>ASC : 升序(默认值) </li>
<li>DESC: 降序</li>
</ul>
<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>SELECT  字段列表  FROM   表名  LIMIT  起始索引, 查询记录数 ;</p>
<p><em>起始索引, 查询记录数 可以理解为从第几条索引开始，往后查多少条记录。（起始索引从0开始）</em></p>
<p>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。</p>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>DCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访 问权限。</p>
<h4 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h4><ol>
<li><p>查询用户</p>
<p> select * from mysql.user;</p>
</li>
<li><p>创建用户</p>
<p> CREATE USER ‘用户名‘@’主机名’ IDENTIFIED BY ‘密码’;</p>
</li>
<li><p>修改用户密码</p>
<p> ALTER USER ‘用户名‘@’主机名’ IDENTIFIED WITH mysql_native_password BY ‘新密码’ ;</p>
</li>
<li><p>删除用户</p>
<p>DROP USER ‘用户名‘@’主机名’ ;</p>
</li>
</ol>
<p><em>主机名可以使用 % 通配。</em></p>
<h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><ol>
<li><p>查询权限</p>
<p>SHOW GRANTS FOR ‘用户名‘@’主机名’ ;</p>
</li>
<li><p>授予权限</p>
<p>GRANT 权限列表 ON 数据库名.表名 TO ‘用户名‘@’主机名’;</p>
</li>
<li><p>撤销权限</p>
<p>REVOKE 权限列表 ON 数据库名.表名 FROM ‘用户名‘@’主机名’;</p>
</li>
</ol>
<p><em>授权时， 数据库名和表名可以使用 * 进行通配，代表所有。</em></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CONCAT(S1,S2,……,Sn)</td>
<td>字符串拼接，将S1，S2，… Sn拼接成一个字符串</td>
</tr>
<tr>
<td>LOWER(str)</td>
<td>将字符串str全部转为小写</td>
</tr>
<tr>
<td>UPPER(str)</td>
<td>将字符串str全部转为大写</td>
</tr>
<tr>
<td>LPAD(str,n,pad)</td>
<td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td>RPAD(str,n,pad)</td>
<td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td>TRIM(str)</td>
<td>去掉字符串头部和尾部的空格</td>
</tr>
<tr>
<td>SUBSTRING(str,start,len)</td>
<td>返回从字符串str从start位置起的len个长度的字符串</td>
</tr>
</tbody></table>
<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CELL(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>FLOOR(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>MOD(x,y)</td>
<td>返回x&#x2F;y的模</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回0~1内的随机数</td>
</tr>
<tr>
<td>ROUND(x,y)</td>
<td>求参数x的四舍五入的值，保留y位小数</td>
</tr>
</tbody></table>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CURDATE()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CURTIME()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>NOW()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>YEAR(date)</td>
<td>获取指定date的年份</td>
</tr>
<tr>
<td>MONTH(date)</td>
<td>获取指定date的月份</td>
</tr>
<tr>
<td>DAY(date)</td>
<td>获取指定date的日期</td>
</tr>
<tr>
<td>DATE_ADD(date, INTERVAL expr type)</td>
<td>返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</td>
</tr>
<tr>
<td>DATEDIFF(date1,date2)</td>
<td>返回起始时间date1 和 结束时间date2之间的天数</td>
</tr>
</tbody></table>
<h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>IF(value , t , f)</td>
<td>如果value为true，则返回t，否则返回 f</td>
</tr>
<tr>
<td>IFNULL(value1 , value2)</td>
<td>如果value1不为空，返回value1，否则 返回value2</td>
</tr>
<tr>
<td>CASE WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td>
<td>如果val1为true，返回res1，… 否则返回default默认值</td>
</tr>
<tr>
<td>CASE [ expr ] WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td>
<td>如果expr的值等于val1，返回res1，… 否则返回default默认值</td>
</tr>
</tbody></table>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>非空约束</td>
<td>限制该字段的数据不能为null</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>唯一约束</td>
<td>保证该字段的所有数据都是唯一、不重复的</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>主键约束</td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td>PRIMARY KEY</td>
</tr>
<tr>
<td>默认约束</td>
<td>保存数据时，如果未指定该字段的值，则采用默认值</td>
<td>DEFAULT</td>
</tr>
<tr>
<td>检查约束(8.0.16版本 之后)</td>
<td>保证字段值满足某一个条件</td>
<td>CHECK</td>
</tr>
<tr>
<td>外键约束</td>
<td>用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td>
<td>FOREIGN KEY</td>
</tr>
</tbody></table>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tb_user(</span><br><span class="line">    id int AUTO_INCREMENT PRIMARY KEY  COMMENT  &#x27;ID唯一标识&#x27;,</span><br><span class="line">    name varchar(10) NOT NULL UNIQUE  COMMENT  &#x27;姓名&#x27; ,</span><br><span class="line">    age int check (age &gt; 0 &amp;&amp; age &lt;= 120)  COMMENT  &#x27;年龄&#x27; ,</span><br><span class="line">    status char(1) default  &#x27;1&#x27;  COMMENT  &#x27;状态&#x27;,</span><br><span class="line">    gender char(1)  COMMENT  &#x27;性别&#x27;</span><br><span class="line"> );</span><br></pre></td></tr></table></figure>

<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><ol>
<li><p>添加外键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">字段名    数据类型,</span><br><span class="line"> ...</span><br><span class="line"> [CONSTRAINT]  [外键名称]  FOREIGN  KEY (外键字段名)   REFERENCES   主表 (主表列名) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ALTER   TABLE  表名   ADD  CONSTRAINT   外键名称   FOREIGN  KEY (外键字段名) REFERENCES  主表 (主表列名) ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除外键</p>
<p>ALTER   TABLE  表名   DROP  FOREIGN  KEY  外键名称;</p>
</li>
<li><p>删除&#x2F;更新行为</p>
<table>
<thead>
<tr>
<th>行为</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NO ACTION</td>
<td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。 (与 RESTRICT 一致) 默认行为</td>
</tr>
<tr>
<td>RESTRICT</td>
<td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。 (与 NO ACTION 一致) 默认行为</td>
</tr>
<tr>
<td>CASCADE</td>
<td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除&#x2F;更新外键在子表中的记录。</td>
</tr>
<tr>
<td>SET NULL</td>
<td>当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（这就要求该外键允许取null）。</td>
</tr>
<tr>
<td>SET DEFAULT</td>
<td>父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)</td>
</tr>
</tbody></table>
<p>具体语法为：</p>
<p>ALTER TABLE  表名  ADD CONSTRAINT  外键名称  FOREIGN KEY  (外键字段)   REFERENCES    主表名 (主表字段名)   ON UPDATE CASCADE ON DELETE CASCADE;</p>
</li>
</ol>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><ul>
<li><p>一对多</p>
<p>案例: 部门 与 员工的关系<br>关系: 一个部门对应多个员工，一个员工对应一个部门<br>实现: <strong>在多的一方建立外键</strong>，指向一的一方的主键</p>
</li>
<li><p>多对多</p>
<p>案例: 学生 与 课程的关系<br>关系: 一个学生可以选修多门课程，一门课程也可以供多个学生选择<br>实现: <strong>建立第三张中间表</strong>，中间表至少包含两个外键，分别关联两方主键</p>
</li>
<li><p>一对一</p>
<p>案例: 用户 与 用户详情的关系<br>关系: 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另<br>一张表中，以提升操作效率<br>实现: <strong>在任意一方加入外键</strong>，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</p>
</li>
</ul>
<h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询"></a>多表查询</h3><p>执行<code> select * from emp , dept</code>，会得到emp和dept所有记录的组合情况，这种现象称之为笛卡尔积。</p>
<p>而在多表查询中，我们是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。</p>
<p>给多表查询加上连接查询的条件可以去除，例<code>select * from emp , dept where emp.dept_id = dept.id;</code></p>
<p><strong>分类：</strong></p>
<p>连接查询：</p>
<p><strong>内连接</strong>：相当于查询A、B交集部分数据</p>
<p><strong>外连接</strong>：</p>
<p><strong>左外连接</strong>：查询左表所有数据，以及两张表交集部分数据<br><strong>右外连接</strong>：查询右表所有数据，以及两张表交集部分数据<br><strong>自连接</strong>：当前表与自身的连接查询，自连接必须使用表别名</p>
<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><ol>
<li><p>隐式内连接</p>
<p> SELECT  字段列表   FROM   表1 , 表2   WHERE   条件 … ;</p>
</li>
<li><p>显式内连接</p>
<p>SELECT  字段列表   FROM   表1  [ INNER ]  JOIN 表2  ON  连接条件 … ;</p>
</li>
</ol>
<p>Tip：一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字 段。</p>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><ol>
<li><p>左外连接</p>
<p> SELECT  字段列表   FROM   表1  LEFT  [ OUTER ]  JOIN 表2  ON  条件 … ;</p>
<p>左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。</p>
</li>
<li><p>右外连接</p>
<p>SELECT  字段列表   FROM   表1  RIGHT  [ OUTER ]  JOIN 表2  ON  条件 … ;</p>
<p>右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。</p>
</li>
</ol>
<p>Tip：左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。</p>
<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p><strong>自连接查询：</strong></p>
<p> SELECT  字段列表   FROM   表A   别名A   JOIN  表A    别名B   ON  条件 … ;</p>
<p><strong>联合查询：</strong></p>
<p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT  字段列表   FROM   表A  ...  </span><br><span class="line">UNION [ ALL ]</span><br><span class="line">SELECT  字段列表  FROM   表B  ....;</span><br></pre></td></tr></table></figure>

<p><strong>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</strong></p>
<p>union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。</p>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p> SELECT  *  FROM   t1   WHERE  column1 &#x3D;  ( SELECT  column1  FROM  t2 );</p>
<p>子查询外部的语句可以是INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 的任何一个。</p>
<p>子查询位置可以是WHERE之后，FROM之后，SELECT之后</p>
<p><strong>分类：</strong></p>
<ul>
<li>标量子查询（子查询结果为单个值）</li>
<li>列子查询(子查询结果为一列)</li>
<li>行子查询(子查询结果为一行)</li>
<li>表子查询(子查询结果为多行多列)</li>
</ul>
<h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。 常用的操作符：&#x3D;  &lt;&gt;  &gt;   &gt;&#x3D;   &lt;  &lt;&#x3D; 。</p>
<p>例：<code>select * from emp where dept_id = (select id from dept where name = &#39;销售部&#39;);</code></p>
<h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h4><p>子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。 常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL</p>
<p>IN：在指定的集合范围之内，多选一</p>
<p>NOT IN：不在指定的集合范围之内</p>
<p>ANY：子查询返回列表中，有任意一个满足即可</p>
<p>SOME：与ANY等同，使用SOME的地方都可以使用ANY</p>
<p>ALL：子查询返回列表的所有值都必须满足</p>
<h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h4><p>子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。 常用的操作符：&#x3D; 、&lt;&gt; 、IN 、NOT IN</p>
<h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><p>子查询返回的结果是多行多列，这种子查询称为表子查询。 常用的操作符：IN</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<h3 id="控制事务"><a href="#控制事务" class="headerlink" title="控制事务"></a>控制事务</h3><ol>
<li><pre><code class="mysql">查看/设置事务提交方式
SELECT  @@autocommit ; 
SET   @@autocommit = 0 ;

提交事务
COMMIT;

回滚事务
ROLLBACK;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   这种方式，我们是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提交, 此时我们执行的DML语句都不会提交, 需要手动的执行commit进行提交。</span><br><span class="line"></span><br><span class="line">2. ~~~mysql</span><br><span class="line">   开启事务</span><br><span class="line">   START TRANSACTION 或 BEGIN;</span><br><span class="line">   提交事务</span><br><span class="line">   COMMIT;</span><br><span class="line">   回滚事务</span><br><span class="line">   ROLLBACK;</span><br></pre></td></tr></table></figure>

例：

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 开启事务</span><br><span class="line">start transaction -- 1. 查询张三余额</span><br><span class="line"></span><br><span class="line">select * from account where name = &#x27;张三&#x27;;-- 2. 张三的余额减少1000</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;-- 3. 李四的余额增加1000</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line"></span><br><span class="line">-- 如果正常执行完毕, 则提交事务</span><br><span class="line">commit;</span><br><span class="line">-- 如果执行过程中报错, 则回滚事务</span><br><span class="line">-- rollback;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h3 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h3><ul>
<li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 </li>
<li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。 </li>
<li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。 </li>
<li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
<p>上述就是事务的四大特性，简称ACID。</p>
<h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><ol>
<li><p>赃读：一个事务读到另外一个事务还没有提交的数据。</p>
<p><img src="/2024/02/15/MySQL%E5%9F%BA%E7%A1%80/image-20240222171937935.png" alt="image-20240222171937935"></p>
</li>
<li><p>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</p>
<p><img src="/2024/02/15/MySQL%E5%9F%BA%E7%A1%80/image-20240222172015377.png" alt="image-20240222172015377"></p>
</li>
<li><p>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 “幻影”。</p>
<p><img src="/2024/02/15/MySQL%E5%9F%BA%E7%A1%80/image-20240222172215336.png" alt="image-20240222172215336"></p>
</li>
</ol>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read uncommitted</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read committed</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable Read(默认)</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Serializable</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>查看事务隔离级别：</p>
<p>SELECT @@TRANSACTION_ISOLATION;</p>
<p>设置事务隔离级别：</p>
<p><code> SET  [ SESSION | GLOBAL ]  TRANSACTION  ISOLATION  LEVEL  &#123; READ UNCOMMITTED |  READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;</code></p>
<p>Tip：事务隔离级别越高，数据越安全，但是性能越低</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Java常用函数</title>
    <url>/2024/03/30/Java%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<p>Java常用集和，字符串api，idea使用小技巧</p>
<span id="more"></span>



<h3 id="Java中map-getOrDefault-方法的使用"><a href="#Java中map-getOrDefault-方法的使用" class="headerlink" title="Java中map.getOrDefault()方法的使用"></a>Java中map.getOrDefault()方法的使用</h3><p>Map.getOrDefault(Object key, V defaultValue)</p>
<p>作用：在map集合中有这个key时，就用这个key的val；如果没有就使用defaultValue默认值</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;cookie&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;18&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;女&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> map.getOrDefault(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;random&quot;</span>);</span><br><span class="line">System.out.println(name);<span class="comment">// cookie，map中存在name,获得name对应的value</span></span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> map.getOrDefault(<span class="string">&quot;score&quot;</span>, <span class="number">80</span>);</span><br><span class="line">System.out.println(score);<span class="comment">// 80，map中不存在score,使用默认值80</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Java集和与数组互转"><a href="#Java集和与数组互转" class="headerlink" title="Java集和与数组互转"></a>Java集和与数组互转</h3><p><strong>集和转为数组：</strong></p>
<p>使用集和的toArray(T[] array)方法，传入的是类型完全一致、长度为 0 的空数组。</p>
<p>错误点：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现ClassCastException 错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"><span class="comment">// 使用无参的toArray()方法，默认的返回类型是Object []</span></span><br><span class="line">Object[] objects = list.toArray();</span><br></pre></td></tr></table></figure>

<p>如果是集和转二维数组，传入类型长度也可以是0，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][]);</span><br></pre></td></tr></table></figure>

<p>说明：使用 toArray 带参方法，数组空间大小的 length：<br>1） <strong>等于 0，动态创建与 size 相同的数组，性能最好。</strong><br>2） 大于 0 但小于 size，重新创建大小等于 size 的数组，增加 GC 负担。<br>3） 等于 size，在高并发情况下，数组创建完成之后，size 正在变大的情况下，负面影响与 2 相同。<br>4） 大于 size，空间浪费，且在 size 处插入 null 值，存在 NPE 隐患</p>
<p><strong>数组转集和：</strong></p>
<p>Arrays.asList()返回的实际上是一个<strong>不允许修改其结构的List</strong>，当前希望对返回的List进行修改结构操作时，按照下面的方式即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer [] arr2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//  传入的参数类型为 Integer时，返回泛型参数就是Integer</span></span><br><span class="line">List&lt;Integer&gt; list2 = Arrays.asList(arr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  新建一个java.util包下的List的实现类即可</span></span><br><span class="line">List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list2);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<h3 id="idea同时编辑多行"><a href="#idea同时编辑多行" class="headerlink" title="idea同时编辑多行"></a>idea同时编辑多行</h3><ol>
<li><em>按住Alt 然后按住鼠标左键拖动光标,就可以同时输入了</em></li>
<li><em>按住Alt+Shift,然后点击鼠标左键,就可以让光标出现在多个位置,同时编辑</em></li>
</ol>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>ThreadLocal解析</title>
    <url>/2024/04/04/ThreadLocal%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<hr>
<p>ThreadLocal实现原理</p>
<span id="more"></span>

<p>ThreadLocal是多线程中对于解决线程安全的一个操作类，它会为每个线程都分配一个独立的线程副本从而解决了变量并发访问冲突的问题。ThreadLocal 同时实现了线程内的资源共享</p>
<h2 id="ThreadLocal三个主要方法"><a href="#ThreadLocal三个主要方法" class="headerlink" title="ThreadLocal三个主要方法"></a>ThreadLocal三个主要方法</h2><p>三个主要方法：</p>
<ul>
<li><p>set(value) 设置值</p>
</li>
<li><p>get() 获取值</p>
</li>
<li><p>remove() 清除值</p>
</li>
</ul>
<p><strong>使用示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            threadLocal.set(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">            print(name);</span><br><span class="line">            System.out.println(name + <span class="string">&quot;-after remove : &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            threadLocal.set(<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">            print(name);</span><br><span class="line">            System.out.println(name + <span class="string">&quot;-after remove : &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">//打印当前线程中本地内存中本地变量的值</span></span><br><span class="line">        System.out.println(str + <span class="string">&quot; :&quot;</span> + threadLocal.get());</span><br><span class="line">        <span class="comment">//清除本地内存中的本地变量</span></span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><img src="/2024/04/04/ThreadLocal%E8%A7%A3%E6%9E%90/image-20230505224626253.png" alt="image-20230505224626253"></p>
<h3 id="get方法-remove方法"><a href="#get方法-remove方法" class="headerlink" title="get方法&#x2F;remove方法"></a>get方法&#x2F;remove方法</h3><p><img src="/2024/04/04/ThreadLocal%E8%A7%A3%E6%9E%90/image-20230505224715087.png" alt="image-20230505224715087"></p>
<h2 id="Thread、THreadLocal、ThreadLocalMap之间关系"><a href="#Thread、THreadLocal、ThreadLocalMap之间关系" class="headerlink" title="Thread、THreadLocal、ThreadLocalMap之间关系"></a>Thread、THreadLocal、ThreadLocalMap之间关系</h2><p><img src="/2024/04/04/ThreadLocal%E8%A7%A3%E6%9E%90/image-20240404193933930.png" alt="image-20240404193933930"></p>
<p><img src="/2024/04/04/ThreadLocal%E8%A7%A3%E6%9E%90/2b569b2f33904ad190946ebacb3ac87atplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p>
<p>两个图像意思一样</p>
<p>ThreadLocalMap是Thread线程的一个成员变量，ThreadLocal是维护ThreadLocalMap这个属性值的一个工具类。<em>Thread线程可以拥有多个ThreadLocal维护的自己线程独享的共享变量</em>。</p>
<p><em>ThreadLocalMap中的Key是Threadlocal 对象，value是要存放的线程局部变量。</em></p>
<p><em><strong>每个线程都有一个ThreadLocalMap成员变量，用ThreadLocal作为key，每个线程可以使用相同的ThreadLocal，那么就相当于把数据存放在自己Map的相同位置，如果还想再存一个，可以再定义一个ThreadLocal，使用set方法往Map里存。</strong></em></p>
<p><em>换种描述理解：</em></p>
<p><em>从图中我们可以当线程使用threadlocal 时，是将threadlocal当做当前线程thread的属性ThreadLocalMap 中的一个Entry的key值，实际上存放的变量是Entry的value值，我们实际要使用的值是value值。value值为什么不存在并发问题呢，因为它只有一个线程能访问。threadlocal我们可以当做一个索引看待，可以有多个threadlocal 变量，不同的threadlocal对应于不同的value值，他们之间互不影响。ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。</em></p>
<h2 id="为什么不用Thread当作KEY-？取数据不是更加方便吗？"><a href="#为什么不用Thread当作KEY-？取数据不是更加方便吗？" class="headerlink" title="为什么不用Thread当作KEY ？取数据不是更加方便吗？"></a>为什么不用Thread当作KEY ？取数据不是更加方便吗？</h2><p>不可以，因为如果现在是只有一个Order对象操作，如果在家一个优惠券信息，那该怎么办？如果重新set不是就把原先的内容给覆盖了吗。</p>
<h2 id="如何在ThreaLocalMap中重新添加一个第二个元素"><a href="#如何在ThreaLocalMap中重新添加一个第二个元素" class="headerlink" title="如何在ThreaLocalMap中重新添加一个第二个元素"></a>如何在ThreaLocalMap中重新添加一个第二个元素</h2><p>只需要 重新创建一个 <code>private ThreadLocal&lt;CardInfo&gt; cardInfoThreadLocal = new ThreadLocal&lt;&gt;();</code> 就可以了，这样当前线程就会有优惠券信息了</p>
<h2 id="ThreadLocalMap发生Hash冲突怎么解决？"><a href="#ThreadLocalMap发生Hash冲突怎么解决？" class="headerlink" title="ThreadLocalMap发生Hash冲突怎么解决？"></a>ThreadLocalMap发生Hash冲突怎么解决？</h2><p>ThreadLocalMap 采用的是开放定址法，如果发生冲突，就往后找相邻的下一个节点，如果相邻的节点是空的，那么久直接存进去，如果不为空，继续往后查找，如果找到数据的最后也没有找到空的，就扩容</p>
<h2 id="如果不想让很多变量里面塞到ThreadLocalMap中造成扩容，怎么办-？"><a href="#如果不想让很多变量里面塞到ThreadLocalMap中造成扩容，怎么办-？" class="headerlink" title="如果不想让很多变量里面塞到ThreadLocalMap中造成扩容，怎么办 ？"></a>如果不想让很多变量里面塞到ThreadLocalMap中造成扩容，怎么办 ？</h2><p>把ThreadLcoal的Value设置为Map值就行了</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>多线程处理订单，把提交的订单信息保存到ThreadLocal中，让每个线程处理自己的内容</li>
<li>存储用户Session</li>
<li>数据库连接，处理数据库事务</li>
</ol>
<h2 id="ThreadLocal-内存泄露的原因"><a href="#ThreadLocal-内存泄露的原因" class="headerlink" title="ThreadLocal 内存泄露的原因"></a>ThreadLocal 内存泄露的原因</h2><p>Entry将ThreadLocal作为Key，值作为value保存，它继承自WeakReference，注意构造函数里的第一行代码super(k)，这意味着ThreadLocal对象是一个「弱引用」</p>
<p>每一个Thread维护一个ThreadLocalMap，在ThreadLocalMap中的Entry对象继承了WeakReference。其中key为使用弱引用的ThreadLocal实例，value为线程变量的副本</p>
<p><img src="/2024/04/04/ThreadLocal%E8%A7%A3%E6%9E%90/image-20230505224857538.png" alt="image-20230505224857538"></p>
<p>在使用ThreadLocal的时候，强烈建议：<strong>务必手动remove</strong></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/6963646002150506533">深度解析ThreadLocal ? Key是当前线程？ - 掘金 (juejin.cn)</a></p>
<p><a href="https://blog.csdn.net/u010445301/article/details/111322569">史上最全ThreadLocal 详解（一）-CSDN博客</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/01/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>next主题设置</title>
    <url>/2024/01/20/next%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>使用next主题</p>
<span id="more"></span>



<p><strong>next主题地址：</strong></p>
<p><a href="https://github.com/next-theme/hexo-theme-next/tree/master">next-theme&#x2F;hexo-theme-next: 🎉 Elegant and powerful theme for Hexo. (github.com)</a></p>
<p><a href="https://blog.csdn.net/qq_32767041/article/details/103284412?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-103284412-blog-131101229.235%5Ev40%5Epc_relevant_anti_vip_base&spm=1001.2101.3001.4242.3&utm_relevant_index=7">Hexo 搭建个人博客（九）NexT 主题进阶配置_hexo next实现代码高亮,利用atra-CSDN博客</a></p>
<p><strong>next使用文档：</strong></p>
<p><a href="https://hexo-next.readthedocs.io/zh-cn/latest/">Hexo-NexT</a></p>
<p><a href="https://theme-next.iissnan.com/">NexT 使用文档 (iissnan.com)</a></p>
<p>更全的文档：<a href="https://theme-next.js.org/mist/">NexT - Theme for Hexo (theme-next.js.org)</a></p>
<p>小图标网站：<a href="https://fontawesome.com/search">Font Awesome</a></p>
<h3 id="设置next主题"><a href="#设置next主题" class="headerlink" title="设置next主题"></a>设置next主题</h3><p>在hexo-blog目录下右键git bash here，运行下面代码</p>
<p><code>git clone https://github.com/next-theme/hexo-theme-next themes/next</code></p>
<p>之后在配置文件中将theme更改为next。</p>
<h4 id="更新next主题"><a href="#更新next主题" class="headerlink" title="更新next主题"></a>更新next主题</h4><p>NexT 每个月都会发布新版本。请在更新前阅读<a href="https://github.com/next-theme/hexo-theme-next/releases">更新说明</a>。你可以通过如下命令更新 NexT。</p>
<p>通过 npm 安装最新版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd hexo-site</span><br><span class="line">$ npm install hexo-theme-next@latest</span><br></pre></td></tr></table></figure>

<p>或者通过 git 更新到最新的 master 分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd themes/next</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure>



<h3 id="next主题配置"><a href="#next主题配置" class="headerlink" title="next主题配置"></a>next主题配置</h3><h4 id="创建新菜单"><a href="#创建新菜单" class="headerlink" title="创建新菜单"></a>创建新菜单</h4><p><strong>打开 themes 的 next 的 _config.yml ，我们此时打开的是主题的配置文件，不是根目录的。</strong></p>
<p>找到第118行或者 搜索menu，即可看到：这里其实就是我们的博客菜单选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home                      #首页</span><br><span class="line">  archives: /archives/ || archive      #归档</span><br><span class="line">  categories: /categories/ || th       #分类</span><br><span class="line">  tags: /tags/ || tags                 #标签</span><br><span class="line">  about: /about/ || user               #关于</span><br><span class="line">  resources: /resources/ || download   #资源</span><br><span class="line">  # schedule: /schedule/ || calendar    #日历</span><br><span class="line">  # sitemap: /sitemap.xml || sitemap    #站点地图，供搜索引擎爬取</span><br><span class="line">  # commonweal: /404/ || heartbeat      #腾讯公益404</span><br></pre></td></tr></table></figure>

<p> “||”前面的是目标链接，后面的是图标名称，next使用的图标全是<a href="https://fontawesome.com.cn/search-download">图标库 - Font Awesome 中文网</a> 这一网站的，有想用的图标直接在fontawesome上面找图标的名称就行。</p>
<p><strong>如果你想添加一个 tags或者about菜单</strong></p>
<ol>
<li>首先在 blog的根目录中打开 git bash黑窗口，输入以下的命令：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hexo new page tags  # tags可以是其他的</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>然后在这个 _config 的menu中把 tags这一项取消注释</p>
<p>添加完成之后，<strong>我们在 blog根目录中打开 source文件夹，即可看到我们的菜单文件夹， tags，打开后，它其实就是一个 md文档！你可以自己在md文档上编辑，然后重新构建看看效果！</strong></p>
</li>
<li><p>同理我们可以<strong>自己创建 菜单，输入 hexo new page xxx</strong>，然后在 <strong>主题的config_yml 的menu中按照其他的格式添加即可 。</strong></p>
</li>
</ol>
<h4 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h4><p>打开博客的<strong>搜索文章的功能</strong></p>
<p>下载<strong>搜索插件</strong>：</p>
<ol>
<li><p>git bash黑窗口中输入：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
</li>
<li><p>主题 的 _config 配置文件中找到 <strong>local_search</strong>，下面的 <strong>enable输入true。</strong></p>
</li>
<li><p>在根目录的 _config.yml 文件中 的末尾添加下面的内容：（选项的内容可以适当修改）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hexo-generator-searchdb</span><br><span class="line">search:</span><br><span class="line">path: search.xml</span><br><span class="line">field: post</span><br><span class="line">format: html</span><br><span class="line">limit: 10000</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="添加不蒜子统计"><a href="#添加不蒜子统计" class="headerlink" title="添加不蒜子统计"></a>添加不蒜子统计</h4><p>在主题的config文件中找到busuanzi_count，直接enable输入true即可。它可以帮助我们<strong>统计网站的观看人数</strong></p>
<h4 id="博客头像设置"><a href="#博客头像设置" class="headerlink" title="博客头像设置"></a>博客头像设置</h4><p>在 主题的 配置文件中搜索：avatar</p>
<p>在主题的 images文件夹中放入你的图片，然后填写路径即可。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: /images/avatar.jpg</span><br><span class="line">  # If true, the avatar will be dispalyed in circle.</span><br><span class="line">  rounded: false</span><br><span class="line">  # If true, the avatar will be rotated with the cursor.</span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure>

<ul>
<li>url：头像的url地址，可以是<code>images/xxx.png</code>，注意images是主题文件夹下的<code>source里面的</code></li>
<li>rounded：头像圆形显示</li>
<li>rotated：头像随鼠标旋转</li>
</ul>
<h4 id="侧边栏添加社交图片"><a href="#侧边栏添加社交图片" class="headerlink" title="侧边栏添加社交图片"></a>侧边栏添加社交图片</h4><p>在主题的 配置文件中搜索<strong>social</strong> 修改即可：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/luumod || fab fa-github</span><br><span class="line">  E-Mail: mailto:<span class="number">1173012900</span>@qq.com || fa fa-envelope</span><br><span class="line">//以下可以直接取消注释，然后在后面添加图标</span><br><span class="line">  #Weibo: https://weibo.com/yourname || fab fa-weibo</span><br><span class="line">  #Google: https://plus.google.com/yourname || fab fa-google</span><br><span class="line">  #Twitter: https://twitter.com/yourname || fab fa-twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || fab fa-facebook</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || fab fa-youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || fab fa-instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || fab fa-skype</span><br></pre></td></tr></table></figure>

<p>注意：图标的设置可以直接访问这里：<a href="https://link.zhihu.com/?target=https://fontawesome.dashgame.com/">font Awesome</a> 直接搜索想要的图标然后复制粘贴即可。</p>
<h4 id="添加RSS订阅"><a href="#添加RSS订阅" class="headerlink" title="添加RSS订阅"></a>添加RSS订阅</h4><p>首先执行命令</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>

<p>打开 Hexo 站点下的 _config.yml ,添加如下配置： 直接在<strong>底部复制粘贴以下内容即可</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># feed</span><br><span class="line"># Dependencies: https://github.com/hexojs/hexo-generator-feed</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: <span class="number">20</span></span><br><span class="line">  hub:</span><br><span class="line">  content:</span><br></pre></td></tr></table></figure>

<h4 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h4><p>打开 themes&#x2F;next&#x2F;_config.yml 文件,搜索关键字 <strong>Blog rolls</strong>： 设置即可：</p>
<ul>
<li>icon：设置图标</li>
<li>title：标题</li>
<li>links：输入你的友情链接，可以直接修改或者添加</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># Blog rolls</span><br><span class="line">links_settings:</span><br><span class="line">  icon: fa fa-link</span><br><span class="line">  title: Links</span><br><span class="line">  # Available values: block | inline</span><br><span class="line">  layout: block</span><br><span class="line"></span><br><span class="line">links:</span><br><span class="line">  #Title: http://yoursite.com</span><br><span class="line"></span><br><span class="line">  CSDN: https://blog.csdn.net/jj6666djdbbd?type=blog</span><br><span class="line">  Luogu: https://www.luogu.com.cn/user/<span class="number">914079</span></span><br></pre></td></tr></table></figure>

<h4 id="隐藏底部由……强力驱动"><a href="#隐藏底部由……强力驱动" class="headerlink" title="隐藏底部由……强力驱动"></a>隐藏底部由……强力驱动</h4><p>在路径 themes\next\layout\_partials中找到 <code>footer.swig</code></p>
<p>找到第 51行，修改为 内容如下： 其实就是在 首尾加了 个 &lt;!- - –&gt;用于隐藏中间的内容，<strong>直接复制下面的覆盖即可，或者直接删除</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- &#123;&#123;- <span class="title function_">__</span>(<span class="string">&#x27;footer.powered&#x27;</span>, <span class="title function_">next_url</span>(<span class="string">&#x27;https://hexo.io&#x27;</span>, <span class="string">&#x27;Hexo&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;theme-link&#x27;</span>&#125;) + <span class="string">&#x27; &amp; &#x27;</span> + <span class="title function_">next_url</span>(next_site, <span class="string">&#x27;NexT.&#x27;</span> + theme.<span class="property">scheme</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;theme-link&#x27;</span>&#125;)) &#125;&#125; --&gt;</span><br></pre></td></tr></table></figure>

<p>另外一种方式：在next的config中，搜索Powered by Hexo &amp; NexT，将powered设置为false</p>
<h4 id="右上角Github图标"><a href="#右上角Github图标" class="headerlink" title="右上角Github图标"></a>右上角Github图标</h4><p>直接在主题配置文件中搜索：<code>github_banner</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># <span class="string">`Follow me on GitHub`</span> banner <span class="keyword">in</span> the top-right corner.</span><br><span class="line"><span class="attr">github_banner</span>:</span><br><span class="line">  <span class="attr">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink</span>: <span class="attr">https</span>:<span class="comment">//github.com/luumod</span></span><br><span class="line">  <span class="attr">title</span>: <span class="title class_">Follow</span> me on <span class="title class_">GitHub</span></span><br></pre></td></tr></table></figure>

<p>然后修改内容即可。</p>
<h4 id="返回顶部按钮显示阅读进度"><a href="#返回顶部按钮显示阅读进度" class="headerlink" title="返回顶部按钮显示阅读进度"></a>返回顶部按钮显示阅读进度</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: false</span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure>

<h4 id="设置网站图标"><a href="#设置网站图标" class="headerlink" title="设置网站图标"></a>设置网站图标</h4><p>在 EasyIcon 中找一张图标，或者去别的网站下载或者制作，然后把图标放在themes&#x2F;next&#x2F;source&#x2F;images 里，下载16x16和32x32的图标后，打开主题配置文件，查找favicon，只要修改small和medium为你的图标路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16.png</span><br><span class="line">  medium: /images/favicon-32x32.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  #android_manifest: /images/manifest.json</span><br><span class="line">  #ms_browserconfig: /images/browserconfig.xml</span><br></pre></td></tr></table></figure>

<h4 id="文章加密访问"><a href="#文章加密访问" class="headerlink" title="文章加密访问"></a>文章加密访问</h4><p>打开<code>themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig</code>文件,插入这样一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    (function () &#123;</span><br><span class="line">        if (&#x27;&#123;&#123; page.password &#125;&#125;&#x27;) &#123;</span><br><span class="line">            if (prompt(&#x27;请输入文章密码&#x27;) !== &#x27;&#123;&#123; page.password &#125;&#125;&#x27;) &#123;</span><br><span class="line">                alert(&#x27;密码错误！&#x27;);</span><br><span class="line">                if (history.length === 1) &#123;</span><br><span class="line">                    location.replace(&quot;http://zxiaoxuan.cn&quot;); // 这里替换成你的首页</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    history.back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>然后在文章上写成类似这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2016/7/13 20:46:25</span><br><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">  - Testing</span><br><span class="line">  - Another Tag</span><br><span class="line">password: 123456</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h4 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h4><p>在站点的配置文件中，搜索<code>highlight</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: true</span><br><span class="line">  tab_replace:</span><br></pre></td></tr></table></figure>

<p>文字自动检测默认不启动，所以改成<code>true</code>使其起作用。</p>
<p>再到主题的配置文件，修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line"># Code Highlight theme</span><br><span class="line"># All available themes: https://theme-next.js.org/highlight/</span><br><span class="line">  ...</span><br><span class="line">  theme:</span><br><span class="line">    light: github-dark</span><br><span class="line">    dark: github-dark</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>各种高亮主题详见<a href="https://theme-next.js.org/highlight/">Highlight (theme-next.js.org)</a></p>
<h4 id="浮动预览内容"><a href="#浮动预览内容" class="headerlink" title="浮动预览内容"></a>浮动预览内容</h4><p>在文章中嵌入标记</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>

<p>会将其之上的内容作为预览内容</p>
<h4 id="返回顶部按钮设置"><a href="#返回顶部按钮设置" class="headerlink" title="返回顶部按钮设置"></a>返回顶部按钮设置</h4><p>back to top按钮的参数在<code>themes\next\source\css\_variables\base.style</code>文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Components</span><br><span class="line">// --------------------------------------------------</span><br><span class="line">// Back to top</span><br><span class="line">$b2t-opacity                  = .8;</span><br><span class="line">$b2t-opacity-hover            = 1;</span><br><span class="line">$b2t-position-bottom          = -100px;</span><br><span class="line">$b2t-position-bottom-on       = 30px;</span><br><span class="line">$b2t-position-right           = 30px;</span><br><span class="line">$b2t-position-right-mobile    = 20px;</span><br><span class="line">$b2t-font-size                = 12px;</span><br><span class="line">$b2t-color                    = white;</span><br><span class="line">$b2t-bg-color                 = $black-deep;</span><br><span class="line"></span><br><span class="line">$sidebar-toggle-inner-size    = 16px;</span><br><span class="line">$sidebar-toggle-padding       = 5px;</span><br><span class="line">$sidebar-toggle-size          = $sidebar-toggle-inner-size + $sidebar-toggle-padding * 2;</span><br></pre></td></tr></table></figure>

<h4 id="在侧边栏添加home等选项"><a href="#在侧边栏添加home等选项" class="headerlink" title="在侧边栏添加home等选项"></a>在侧边栏添加home等选项</h4><p>在next主题的配置文件下，搜索social，添加如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Social Links</span><br><span class="line"># Usage: `Key: permalink || icon`</span><br><span class="line"># Key is the link label showing to end users.</span><br><span class="line"># Value before `||` delimiter is the target permalink, value after `||` delimiter is the name of Font Awesome icon.</span><br><span class="line">social:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  GitHub: https://github.com/blogwml || fab fa-github</span><br><span class="line">  ……</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>hexo搭建个人博客</title>
    <url>/2024/01/17/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>使用hexo搭建个人博客</p>
<span id="more"></span>



<p>参考资料：</p>
<p><a href="https://blog.csdn.net/weixin_45019350/article/details/121901433">Hexo-零基础搭建个人博客(详解)_hexo博客-CSDN博客</a></p>
<p><a href="https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.788.recommend_more_video.0&vd_source=b1ac522e8f77602d825ea916998cf075">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo_哔哩哔哩_bilibili</a></p>
<p><a href="https://pdpeng.github.io/2022/01/19/setup-personal-blog/#%E6%9C%AC%E5%9C%B0%E7%BD%91%E7%AB%99">https://pdpeng.github.io/2022/01/19/setup-personal-blog/#%E6%9C%AC%E5%9C%B0%E7%BD%91%E7%AB%99</a></p>
<p><a href="https://www.bilibili.com/read/cv12633102/">2021最全hexo搭建博客+matery美化+使用（保姆级教程） - 哔哩哔哩 (bilibili.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/60578464">使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/qq_36667170/article/details/118163563">换电脑后怎么迁移hexo博客？_hexo换电脑了怎么办-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_59039063/article/details/132459418">解决使用Hexo搭建个人博客遇到的一些问题_hexo总连不上github-CSDN博客</a></p>
<h1 id="Hexo-GitHub-搭建个人免费博客"><a href="#Hexo-GitHub-搭建个人免费博客" class="headerlink" title="Hexo+GitHub 搭建个人免费博客"></a>Hexo+GitHub 搭建个人免费博客</h1><h2 id="先在本地跑起来"><a href="#先在本地跑起来" class="headerlink" title="先在本地跑起来"></a>先在本地跑起来</h2><ol>
<li><p>安装Node.js</p>
<p><a href="https://nodejs.org/en/download/">Node.js — Download (nodejs.org)</a></p>
</li>
<li><p>安装git</p>
</li>
<li><p>安装hexo</p>
<p><img src="/2024/01/17/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20240117090537651.png" alt="image-20240117090537651"></p>
</li>
<li><p>新建博客文件夹<em>hexo-blog</em></p>
</li>
<li><p>打开该文件夹右键Git Bash Here</p>
</li>
<li><p>hexo初始化和本地预览</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init #初始化</span><br><span class="line">npm install #安装组件</span><br></pre></td></tr></table></figure>

<p>github无法访问：<a href="https://blog.csdn.net/langfeiyes/article/details/128487969">不用梯子，GitHub也能访问并提速_github host-CSDN博客</a>，之后再执行hexo init</p>
<p>完成后依次输入下面命令，<strong>启动本地服务器进行预览</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g   # 生成页面</span><br><span class="line">hexo s   # 启动预览</span><br></pre></td></tr></table></figure>

<p><strong>访问</strong> <code>http://localhost:4000</code><strong>，出现 Hexo 默认页面，本地博客安装成功！</strong></p>
<p><strong>Tips：</strong>如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 <code>hexo server -p 5000</code> 更改端口号后重试。</p>
</li>
</ol>
<h2 id="部署-Hexo-到-GitHub-Pages"><a href="#部署-Hexo-到-GitHub-Pages" class="headerlink" title="部署 Hexo 到 GitHub Pages"></a>部署 Hexo 到 GitHub Pages</h2><ol>
<li><p>新建github仓库</p>
<p>仓库名称限制了为你的：用户名+.github.io</p>
</li>
<li><p>安装hexo上传插件</p>
<p><code>npm install hexo-deployer-git --save</code></p>
</li>
<li><p>修改hexo配置文件指定仓库路径</p>
<p><img src="/2024/01/17/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20240117114910966.png" alt="image-20240117114910966"></p>
</li>
<li><p>推送站点到github</p>
<p><code>hexo d</code></p>
<p><img src="/2024/01/17/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20240117115655665.png" alt="image-20240117115655665"></p>
</li>
<li><p>成功</p>
<p><img src="/2024/01/17/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20240117115809155.png" alt="image-20240117115809155"></p>
</li>
<li><p><strong>漏掉：</strong>配置SSH免密登录</p>
<p>右键 -&gt; Git Bash Here，<strong>设置用户名和邮箱</strong>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;GitHub 用户名&quot;</span><br><span class="line">git config --global user.email &quot;GitHub 邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>创建SSH密钥：</p>
<p>输入 <code>ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;</code>，然后一路回车。</p>
<p><strong>添加密匙：</strong></p>
<p>进入 [C:\Users\用户名.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。</p>
<p>登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。</p>
<p>Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。</p>
<p><img src="/2024/01/17/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20240117183853134.png" alt="image-20240117183853134"></p>
</li>
</ol>
<h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>到GitHub上搜索hexo主题或者hero自带的主题<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p>
<p>一般步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、下载解压</span><br><span class="line">2、放到主题包themes文件夹下面</span><br><span class="line">3、在hero配置文件_config.yml中修改为喜欢主题的名字</span><br><span class="line">4、hero server启动即可访问</span><br></pre></td></tr></table></figure>

<p>本地调试完之后，可以更新到github上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//清理</span><br><span class="line">hexo clean</span><br><span class="line">//构建静态文件</span><br><span class="line">hexo g</span><br><span class="line">//上传至仓库</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>







<h3 id="网站设置"><a href="#网站设置" class="headerlink" title="网站设置"></a>网站设置</h3><p><a href="https://hexo.io/zh-cn/docs/configuration">配置 | Hexo</a></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;name&quot;       # 新建文章</span><br><span class="line">hexo new page &quot;name&quot;  # 新建页面</span><br><span class="line">hexo g                # 生成页面</span><br><span class="line">hexo d                # 部署</span><br><span class="line">hexo g -d             # 生成页面并部署</span><br><span class="line">hexo s                # 本地预览</span><br><span class="line">hexo clean            # 清除缓存和已生成的静态文件</span><br><span class="line">hexo help             # 帮助</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>信息订阅聚合工具</title>
    <url>/2024/01/24/%E4%BF%A1%E6%81%AF%E8%AE%A2%E9%98%85%E8%81%9A%E5%90%88%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>信息聚合app和网站</p>
<span id="more"></span>

<h3 id="QiReader——基于Web的全平台RSS阅读器"><a href="#QiReader——基于Web的全平台RSS阅读器" class="headerlink" title="QiReader——基于Web的全平台RSS阅读器"></a>QiReader——基于Web的全平台RSS阅读器</h3><p><a href="https://www.v2ex.com/t/834418">2022 还有人用 RSS 吗？我做了一个 RSS 服务: QiReader - 全平台 RSS 阅读器 (PWA) - V2EX</a></p>
<p>没有app，只有网页端</p>
<p>网站链接：</p>
<p><a href="https://www.qireader.com.cn/">全部订阅源 - Qi Reader</a></p>
<h3 id="今日热榜"><a href="#今日热榜" class="headerlink" title="今日热榜"></a>今日热榜</h3><p><a href="https://tophub.today/">今日热榜官网 (tophub.today)</a></p>
<p><a href="https://tophub.app/">https://tophub.app【备用域名】</a></p>
<p>app、网页端</p>
<h3 id="摸鱼kik"><a href="#摸鱼kik" class="headerlink" title="摸鱼kik"></a>摸鱼kik</h3><p>app、windows</p>
<p><a href="https://moyukik.sohu.com/">摸鱼kik-每刻都值得摸鱼 (sohu.com)</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>博客菜单设置</title>
    <url>/2024/01/21/%E5%8D%9A%E5%AE%A2%E8%8F%9C%E5%8D%95%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>分类、标签等菜单栏设置</p>
<span id="more"></span>



<h3 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h3><p>打开主题配置文件即themes&#x2F;next下的_config.yml，查找menu，将前面的#删除就行了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home                      #首页</span><br><span class="line">  archives: /archives/ || archive      #归档</span><br><span class="line">  categories: /categories/ || th       #分类</span><br><span class="line">  tags: /tags/ || tags                 #标签</span><br><span class="line">  about: /about/ || user               #关于</span><br><span class="line">  resources: /resources/ || download   #资源</span><br><span class="line">  # schedule: /schedule/ || calendar    #日历</span><br><span class="line">  # sitemap: /sitemap.xml || sitemap    #站点地图，供搜索引擎爬取</span><br><span class="line">  # commonweal: /404/ || heartbeat      #腾讯公益404</span><br></pre></td></tr></table></figure>

<p>“||”前面的是目标链接，后面的是图标名称，next使用的图标全是<a href="https://fontawesome.com.cn/search-download">图标库 - Font Awesome 中文网</a> 这一网站的，有想用的图标直接在fontawesome上面找图标的名称就行。resources 是我自己添加的。</p>
<p><strong>新添加的菜单需要翻译对应的中文，打开 <code>theme/next/languages/zh-CN.yml</code>，在 menu 下设置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: 首页</span><br><span class="line">  archives: 归档</span><br><span class="line">  categories: 分类</span><br><span class="line">  tags: 标签</span><br><span class="line">  about: 关于</span><br><span class="line">  resources: 资源</span><br><span class="line">  search: 搜索</span><br></pre></td></tr></table></figure>



<p>在根目录下打开 <code>Git Bash</code>，输入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;about&quot;</span><br><span class="line">hexo new page &quot;resources&quot;</span><br></pre></td></tr></table></figure>

<p>此时在根目录的sources文件夹下会生成categories、tags、about、resources四个文件，每个文件中有一个 <code>index.md</code> 文件，修改内容分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2020-02-10 22:07:08</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2020-02-10 22:07:08</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 关于</span><br><span class="line">date: 2020-02-10 22:07:08</span><br><span class="line">type: &quot;about&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 资源</span><br><span class="line">date: 2020-02-10 22:07:08</span><br><span class="line">type: &quot;resources&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p> 注：如果有启用评论，默认页面带有评论。需要关闭的话，添加字段 comments 并将值设置为false。</p>
<h3 id="给文章添加标签、分类"><a href="#给文章添加标签、分类" class="headerlink" title="给文章添加标签、分类"></a>给文章添加标签、分类</h3><p>新建好文章文档，如下方式设置文章的标签和分类</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">博客菜单设置</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2024-01-21 20:49:18</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">第一个标签</span></span><br><span class="line"><span class="attr">categories:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">test</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">二级分类</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p><strong>上面分类为二级分类，test分类下的二级分类</strong>。可同时设置多标签，但只能有一个分类</p>
<p>tip：删除标签的话，将含有该标签的文章删除或更改为其他标签，hexo clean后就删除了</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>第一个标签</tag>
      </tags>
  </entry>
  <entry>
    <title>博客插入图片</title>
    <url>/2024/01/28/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<hr>
<p>博客插入图片设置与教程</p>
<span id="more"></span>



<p>众所周知，在md文件中插入图片的语法为<code>![]()</code>。</p>
<p>其中<strong>方括号</strong>是图片描述，<strong>圆括号</strong>是图片路径。</p>
<p>一般来说有三种图片路径，分别是<strong>相对路径，绝对路径和网络路径</strong>。</p>
<p>所谓的网络路径就是直接引用网上的图片，直接复制图片地址，放在圆括号中就完事了。</p>
<p>这种方式十分的方便，但是也存在一定的问题：</p>
<ul>
<li>图片失效导致无法加载；</li>
<li>打开网页后要再请求加载图片；</li>
<li>原网站限制，如微信公众号的图片会变得不可见等。</li>
</ul>
<p>这种方式算是有利有弊。</p>
<p>绝对路径是图片在计算机中的绝对位置，相对路径是相对于当前文件的路径。</p>
<p>由于我们的博客是要部署在网站上，部署后会生成新的文件目录，所以我们选择使用相对路径的方式。</p>
<p>在hexo中使用<strong>文章资源文件夹</strong>需要在<code>config.yaml</code>文件中更改一下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>当该配置被应用后，使用<code>hexo new</code>命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。</p>
<blockquote>
<p>由于项目会生成新的文件目录，同时会解析Markdown中的图片路径，会导致一个问题。<br>如在一个文件目录下，博客名为<code>1.md</code>，相应的存在一个<code>1</code>文件夹存放图片<code>image.jpg</code>。<br>在Typora编辑器中，普通的md文件使用<code>![](1/image.jpg)</code>能在编辑器中正常显示图片。<br>在hexo中，按理说应该是使用<code>![](image.jpg)</code>，但网页中却无法正常显示。<br>此时应该使用这样的方式来引入图片：</p>

</blockquote>
<p>虽然可以正常引用图片了，但是这种引用图片的方式只有一句话能形容，wtf。</p>
<h2 id="图片插件"><a href="#图片插件" class="headerlink" title="图片插件"></a><strong>图片插件</strong></h2><p>插件<a href="https://link.zhihu.com/?target=https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>解决了这个问题。可以只用<code>npm install hexo-renderer-marked</code>命令直接安装，之后在<code>config.yaml</code>中更改配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>之后就可以在使用<code>![](image.jpg)</code>的方式愉快的插入图片了。</p>
<p>我们做了这么多都是为了方便，那么为什么不再方便一点呢。</p>
<h2 id="hexo与Typora的完美结合"><a href="#hexo与Typora的完美结合" class="headerlink" title="hexo与Typora的完美结合"></a><strong>hexo与Typora的完美结合</strong></h2><p>上述是从文章资源文件夹中引用图片，前提是<strong>先将图片放入到文章资源文件夹</strong>，如果图片数量众多的话，一张一张的放很影响效率。但是不用怕，我们有很方便的解决方法。</p>
<p><strong>Typora</strong>是我非常喜欢的Markdown文本编辑器，在之前的文章中也介绍过一点。</p>
<p>Typora对于插入图片的支持做得非常好，在<code>文件-&gt;偏好设置</code>或者直接<code>&lt;C-,&gt;</code>进入设置。</p>
<p><img src="/2024/01/28/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/v2-52220b2dba6901ee2181b72951d25a7b_720w.webp" alt="img"></p>
<p>使用该配置后，可以直接复制网页中的图片地址，粘贴到Typora中后，会直接复制该图片到文章资源文件夹，同时自动更改路径。</p>
<p>如复制网络路径的图片<code>https://...../image.jpg</code>粘贴到Typora中叫<code>文章名</code>的文章后，图片会自动变为<code>![](文章名/image.jpg)</code>。</p>
<p>但我们知道部署后，文件路径是不同的，所以当我们插入完所有的图片后，我们还需要删除每个图片路径中的<code>文件名/</code>。不慌，也很简单。</p>
<p>在Typora编辑器中，使用<code>&lt;C-f&gt;</code>快捷键，将所有的<code>文章名/</code>替换为空即可删除。</p>
<p><img src="/2024/01/28/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/v2-9202796d27f4659d96ff13b11e6808c1_720w.png" alt="img"></p>
<p>然后再将博客上传，图片就会随着文章一起打包。在网页中就可以看到正常显示的图片，大功告成。</p>
<p>————-本地预览不显示图片的问题—————-</p>
<p>在typora的设置中选择图片工具，为文章设置一个图片根目录。设置方式如下，之后选中存放图片的目录即可，根据不同版本的typora该设置项可以能在不能的位置。</p>
<p><img src="/2024/01/28/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/v2-8d28ac51aedad913907c45b4907d325f_720w.webp" alt="img"></p>
<p>格式 -&gt; 图片工具 -&gt; 设置图片根目录</p>
<p>————再更————</p>
<p>为了方便，可以在<code>scaffolds -&gt; post</code>中添加如下设置。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">typora-root-url:</span> &#123;&#123; <span class="string">title</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这样每次执行hexo new命令新建文章的时候，会在Front Matter中自动添加该配置，如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">typora-root-url: hexo图片显示问题</span><br></pre></td></tr></table></figure>

<p>至此，在本地和服务器的图片都能正常预览。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zhuanlan.zhihu.com/p/265077468">hexo博客如何插入图片 - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/u014155600/article/details/128950724">hexo文章插入图片方法小结_hexo 图片-CSDN博客</a></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>多线程基础</title>
    <url>/2024/02/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<hr>
<p>Java多线程基础</p>
<span id="more"></span>

<p><strong>并发：</strong>两个或多个任务在同一时间段执行，多个任务交替执行（“发”牌，一张一张发）。单核cpu实现的多任务就是并发。</p>
<p><strong>并行：</strong>两个或多个任务在同一时刻执行。多核cpu可以实现并行。并发和并行的行为可以同时存在（多核cpu中的一个核在执行多个任务是并发）</p>
<h2 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h2><p>线程类图：</p>
<p><img src="/2024/02/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/image-20240203190941800.png" alt="image-20240203190941800"></p>
<h3 id="使用线程的两种方法"><a href="#使用线程的两种方法" class="headerlink" title="使用线程的两种方法"></a>使用线程的两种方法</h3><ol>
<li>继承Thread类，重写run方法</li>
<li>实现Runable接口，重写run方法</li>
</ol>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p><em>案例：开启一个线程，每个一秒控制台输出“hello，dog”</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  <span class="comment">//重写 run 方法，写上自己的业务逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//该线程每隔 1 秒。在控制台输出 “喵喵, 我是小猫咪”</span></span><br><span class="line">            System.out.println(<span class="string">&quot;喵喵, 我是小猫咪&quot;</span> + (++times) + <span class="string">&quot; 线程名=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//让该线程休眠 1 秒 ctrl+alt+t</span></span><br><span class="line">            <span class="comment">//这里try-catch是保证该线程在sleep时还是能感知响应，能够响应中断，不会睡死</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (times == <span class="number">8</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//当 times 到 8, 退出 while, 这时线程也就退出..</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>主函数：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); <span class="comment">// Cat类继承Thread后，cat对象可以当作线程使用</span></span><br><span class="line">cat.start();</span><br></pre></td></tr></table></figure>

<p><em><strong>tip：main线程启动一个子线程Thread-0，主线程不会阻塞，会继续执行</strong></em></p>
<p>start底层：（start0()是本地方法，是JVM调用，底层是C&#x2F;C++实现）</p>
<p><img src="/2024/02/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/image-20240203211222841.png" alt="image-20240203211222841"></p>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p><em>java是单继承的，有时候一个类已经继承了某个父类，无法再继承Thread类来创建线程</em></p>
<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; <span class="comment">//通过实现 Runnable 接口，开发线程</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//普通方法</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小狗汪汪叫..hi&quot;</span> + (++count) + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//休眠 1 秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="comment">//dog.start(); 这里不能调用 start</span></span><br><span class="line"><span class="comment">//创建 Thread 对象，把 dog 对象(实现 Runnable),放入 Thread</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(dog);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>



<p><em><strong>Thread是代理模式，下面模拟一个极简的Thread类</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadProxy</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//属性，类型是 Runnable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.run();<span class="comment">//动态绑定</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadProxy</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        start0();<span class="comment">//这个方法时真正实现多线程方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span> &#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setName		<span class="comment">//设置线程名称</span></span><br><span class="line">getName		<span class="comment">//返回该线程名称</span></span><br><span class="line">start 		<span class="comment">//使该线程开始执行; Java 虚拟机底层调用该线程的 start0 </span></span><br><span class="line">run 		<span class="comment">//调用线程对象 run </span></span><br><span class="line">setPriority <span class="comment">//更改线程的优先级</span></span><br><span class="line">getPriority <span class="comment">//获取线程的优先级</span></span><br><span class="line">sleep	<span class="comment">//在指定的毫秒数内让当前正在执行的线程休眠 (暂停执行)</span></span><br><span class="line">interrupt <span class="comment">//中断线程,一般用于中断正在休眠的线程</span></span><br></pre></td></tr></table></figure>

<p><strong>tip：interrupt 中断线程，一般用于中断正在休眠的线程，相当于提前结束休眠</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span>：线程的礼让，让出cpu，让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功。</span><br><span class="line">join：线程的插队。线程一旦插入成功，肯定先执行完插入的线程所有的任务。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用户线程：也叫工作线程，就是程序里的自定义线程</p>
<p>守护线程：为工作线程服务，当用户线程结束，守护线程自动结束，常见的有垃圾回收机制。</p>
<p>使用方法为：</p>
<p>thread.setDaemon(true);</p>
<p>thread.start();</p>
</blockquote>
<h3 id="线程运行状态"><a href="#线程运行状态" class="headerlink" title="线程运行状态"></a>线程运行状态</h3><p><img src="/2024/02/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/image-20240204120127823.png" alt="image-20240204120127823"></p>
<h2 id="线程同步、互斥"><a href="#线程同步、互斥" class="headerlink" title="线程同步、互斥"></a>线程同步、互斥</h2><p>synchronized用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步代码块</span></span><br><span class="line"><span class="keyword">synchronized</span>(对象)&#123;<span class="comment">//得到对象的锁，才能操作同步代码</span></span><br><span class="line">    <span class="comment">//要同步的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//synchronized还可以放在方法声明中，表示整个方法为同步方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="comment">//要同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>同步方法如果没有使用static修饰，默认锁对象为this</li>
<li>如果使用static，默认锁对象为：当前类.class</li>
</ol>
<p><strong>Tip：同一对象开启的多个线程，是同一锁，同类不同对象开启对应线程，是多把不同的锁，想要锁住就加静态，这样锁的就是该类创建的所有对象了</strong></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>字符串与其他数据类型互转</title>
    <url>/2024/02/06/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BA%92%E8%BD%AC/</url>
    <content><![CDATA[<hr>
<p>字符串与其他数据类型互转</p>
<span id="more"></span>

<h4 id="基本数据类型转字符串"><a href="#基本数据类型转字符串" class="headerlink" title="基本数据类型转字符串"></a>基本数据类型转字符串</h4><ol>
<li>将基本数据类型与空字符串（” “）连接（+）即可获得其所对应的字符串</li>
<li>调用String 类中的valueOf()方法返回相应字符串</li>
<li>使用包装类的toString()方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">hh</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> hh + <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.valueOf(hh);</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> Integer.toString(hh);</span><br></pre></td></tr></table></figure>

<h4 id="字符串转基本数据类型"><a href="#字符串转基本数据类型" class="headerlink" title="字符串转基本数据类型"></a>字符串转基本数据类型</h4><ol>
<li>调用基本数据类型对应的包装类中的方法parseXXX(String)</li>
<li>对应包装类型的valueOf(String)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">str1</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line"><span class="type">int</span> <span class="variable">str2</span> <span class="operator">=</span> Integer.valueOf(str);</span><br><span class="line"><span class="comment">// 当然先要确定你的字符串是可以转换为int类型的</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串转字符数组（char-）"><a href="#字符串转字符数组（char-）" class="headerlink" title="字符串转字符数组（char[]）"></a>字符串转字符数组（char[]）</h4><p>使用字符串的toCharArray()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] chs=line.toCharArray();</span><br><span class="line">System.out.println(Arrays.toString(chs));</span><br></pre></td></tr></table></figure>

<h4 id="字符数组转成字符串"><a href="#字符数组转成字符串" class="headerlink" title="字符数组转成字符串"></a>字符数组转成字符串</h4><ol>
<li>直接将字符数组作为参数构造String对象</li>
<li>使用String的valueOf()方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] str = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;  &#x27;</span>, <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>&#125;;  <span class="comment">//创建一个字符数组</span></span><br><span class="line"><span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(str);</span><br><span class="line"><span class="type">String</span> <span class="variable">string2</span> <span class="operator">=</span> String.valueOf(str);</span><br></pre></td></tr></table></figure>

<h4 id="字符串转字节数组（byte-）"><a href="#字符串转字节数组（byte-）" class="headerlink" title="字符串转字节数组（byte[]）"></a>字符串转字节数组（byte[]）</h4><p>getBytes()：使用系统的默认字符集将字符串编码为 byte 序列，并将结果存储到一个新的 byte 数组中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span><span class="string">&quot;我爱中国,中国爱我&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编码: 字节数组</span></span><br><span class="line"><span class="type">byte</span>[] datas = msg.getBytes();  <span class="comment">//默认使用工程的字符集,当前系统默认为UTF-8,可以理解为中文两个字节,非中文1个字节</span></span><br><span class="line">System.out.println(datas.length);<span class="comment">// 25</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//编码: 其他字符集</span></span><br><span class="line">datas = msg.getBytes(<span class="string">&quot;UTF-16LE&quot;</span>);</span><br><span class="line">System.out.println(datas.length);<span class="comment">// 18</span></span><br><span class="line">        </span><br><span class="line">datas = msg.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">System.out.println(datas.length);<span class="comment">// 17</span></span><br></pre></td></tr></table></figure>

<h4 id="字节数组转字符串"><a href="#字节数组转字符串" class="headerlink" title="字节数组转字符串"></a>字节数组转字符串</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public String(byte bytes[])</td>
<td>使用系统<code>默认字符集</code>解码字节数组，构造一个新的字符串</td>
</tr>
<tr>
<td>public String(byte bytes[], String charsetName)</td>
<td>使用指定的编码来解码字节数组，<code>构造一个新的字符串</code></td>
</tr>
<tr>
<td>public String(byte bytes[], int offset, int length, String charsetName)</td>
<td>使用指定字符集解码指定的 byte 数组，<code>构造一个新的 字符串</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;我爱中国,中国爱我&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编码: 字节数组</span></span><br><span class="line"><span class="type">byte</span>[] datas = msg.getBytes();  <span class="comment">//默认使用工程的字符集</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解码: 字符串 String•(byte[] bytes, int offset, int length, String charsetName)</span></span><br><span class="line">msg = <span class="keyword">new</span> <span class="title class_">String</span>(datas, <span class="number">0</span>, datas.length, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">System.out.println(msg);<span class="comment">// 我爱中国,中国爱我</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>拿下面试</title>
    <url>/2024/03/24/%E6%8B%BF%E4%B8%8B%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<hr>
<p>面试技巧及面经汇总</p>
<span id="more"></span>



<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ol>
<li>回答可以结合项目，项目中是怎么用的</li>
<li>要先说结论，让面试官知道你知道</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>秋招</category>
      </categories>
  </entry>
  <entry>
    <title>拿下八股</title>
    <url>/2024/03/24/%E6%8B%BF%E4%B8%8B%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[<hr>
<p>八股汇总</p>
<span id="more"></span>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.yuque.com/coding-guide/bckbvp/rl7g3i">我的八股文学习路线及攻略 (yuque.com)</a></p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指查询一个不存在的数据，先在redis中查，redis中没有，然后向数据库中查，但是数据库中也没有，如果有大量这种请求都去查询数据库，会给数据库带来很大压力。</p>
<p><strong>解决方法：</strong></p>
<ol>
<li><p>缓存空值：如果说查询数据库不存在这个数据，就把空值缓存到redis中</p>
<p>优点：简单</p>
<p>缺点：如果有很多这样的请求，会占用redis缓存，消耗内存，还有可能会造成不一致的问题</p>
</li>
<li><p>布隆过滤器</p>
<p>布隆过滤器主要用于检索一个元素在数据库中是否存在，可以使用redisson实现布隆过滤器。</p>
<p>它的底层是一个bitmap，每个位置只能存储0或1，一个key来了之后经过多个不同的hash函数运算得到多个hash值，如果hash值对应的位置全是1，则数据库中有这个值。</p>
<p>优点：内存占用少</p>
<p>缺点：存在误判，bitmap长度越大，误判率越小。redisson可以设置这个误判率</p>
</li>
</ol>
]]></content>
      <categories>
        <category>秋招</category>
      </categories>
  </entry>
  <entry>
    <title>拿下项目</title>
    <url>/2024/03/24/%E6%8B%BF%E4%B8%8B%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<hr>
<p>项目总结及常见面试问题</p>
<span id="more"></span>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.yuque.com/coding-guide/bckbvp/xml7ki">后端面试项目考察及准备(长文攻略) (yuque.com)</a></p>
<h2 id="牛客论坛"><a href="#牛客论坛" class="headerlink" title="牛客论坛"></a>牛客论坛</h2><p><img src="/2024/03/24/%E6%8B%BF%E4%B8%8B%E9%A1%B9%E7%9B%AE/20210520202315292.png" alt="img"></p>
<p><img src="/2024/03/24/%E6%8B%BF%E4%B8%8B%E9%A1%B9%E7%9B%AE/image-20240321220816246.png" alt="image-20240321220816246"></p>
<h3 id="项目亮点"><a href="#项目亮点" class="headerlink" title="项目亮点"></a>项目亮点</h3><ol>
<li>使用Redis实现了点赞和关注功能</li>
<li>使用Kafka实现了异步的站内通知</li>
<li>使用Spring Security实现了权限控制</li>
</ol>
<h3 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h3><p>难点感觉主要就是评论那一块的业务，评论表主要有这几个字段：id, user_id, entity_type, entity_id, target_id, content, status, create_time。首先评论这个表中有entity_type, entity_id, target_id这三个字段来确定评论的对象，entity_type字段（int型）1：表示此条评论是对帖子进行的一个评论，2：表示此条评论是对1级评论进行的2级评论；entityId字段（int型）如果entity_type字段为1则此字段存储的是帖子的id，如果entity_type字段为2则此字段存储的是对哪个1级评论进行的评论；targetId字段（int型）可为空，为空并且entityId为2则表示此评论没有哪个2级评论进行评论，不为空且entityId为2则表示此评论是对一个2级评论的回复评论。</p>
<p>entity_type字段为1、表示是对帖子进行的评论</p>
<p>entity_type字段为2、并且没有targetId字段信息，表示是对1级评论进行的评论</p>
<p>entity_type字段为2、并且有targetId字段信息，表示是对2级评论进行的评论</p>
<p>添加完评论之后，调用消息队列的生产者，在评论这个topic里添加消息，然后消费者就去处理这个消息，具体就是系统会给相关用户发一条系统通知，某某某给你评论了。</p>
<p>提交表单，添加评论的时候用的</p>
<h3 id="如何记录用户的登陆状态"><a href="#如何记录用户的登陆状态" class="headerlink" title="如何记录用户的登陆状态"></a>如何记录用户的登陆状态</h3><p>用户输入用户名，密码提交之后，会给用户创建一个ticket，并放入cookie返回给浏览器，下一次访问时，浏览器会自动带上这个含有ticket的cookie，服务端可以根据cookie确定用户的登陆状态，以及根据ticket查询到用户id，就可以知道用户的信息了。</p>
<p>最开始，是建了一个login_ticket表，里面存储用户的id，ticket，过期时间，以及用户状态。然后之后这部分就用Redis来实现了</p>
<p>怎么用Redis实现的：</p>
<p>就是把使用uuid生成的ticket作为key，然后用户登录凭证的一些信息作为value，</p>
<h3 id="为什么使用Redis"><a href="#为什么使用Redis" class="headerlink" title="为什么使用Redis"></a>为什么使用Redis</h3><p>因为Redis它把数据存储在内存中，读写新能很好，就比如说我存储用户的登录凭证，以及根据这个凭证查询用户信息，这个访问的频率是非常高的，如果都去访问数据库，会给数据库带来很大的压力，所以用Redis可以改善这一块的问题。</p>
<h3 id="拦截器的使用"><a href="#拦截器的使用" class="headerlink" title="拦截器的使用"></a>拦截器的使用</h3><p>在请求开始时查询登录用户，在本次请求中持有用户数据</p>
<p>使用拦截器Interceptor来拦截所有的用户请求，判断请求中的cookie是否存在有效的ticket，如果有的话就将查询用户信息并将用户的信息写入ThreadLocal在本次请求中持有用户，将每个线程的threadLocal都存到一个叫做hostHolder的实例中，根据这个实例就可以在本次请求中全局任意的位置获取用户信息。</p>
<blockquote>
<p>redis是存储用户登录的状态，是在用户登录之后，跨不同的请求的，而使用ThreadLocal具体针对的是一次请求，在这次请求中去存储用户信息，方便程序的开发，比如说我请求了帖子详情页面，去做评论或者回复，就可以直接从threadLocal中取到用户的信息，进行编码。</p>
</blockquote>
<h3 id="如何理解生产者，消费者"><a href="#如何理解生产者，消费者" class="headerlink" title="如何理解生产者，消费者"></a>如何理解生产者，消费者</h3><p>生产者发消息是主动调用，消费者接受消息是被动调用的过程</p>
<h3 id="为什么用消息队列，好处"><a href="#为什么用消息队列，好处" class="headerlink" title="为什么用消息队列，好处"></a>为什么用消息队列，好处</h3><p>首先是解耦，可以在不同的主题中去放入消息，然后消费者去处理不同主题中的消息</p>
<p>然后主要是异步通信，就是用户可能不需要立即去处理这个消息，就使用异步处理机制，先把消息放入队列，然后就可以处理其他的事情了，让消费者去处理这个主题里面的消息。</p>
<p>还有就是提高峰值处理能力，使关键组件能够顶住突发的访问压力。</p>
<h3 id="如何使用Kafka做系统通知"><a href="#如何使用Kafka做系统通知" class="headerlink" title="如何使用Kafka做系统通知"></a>如何使用Kafka做系统通知</h3><p>当触发点赞关注评论这些事件时，生产者就生产消息，放到消息队列中，然后消费者监听到消息之后，将消息队列中的事件取出，然后封装成Message对象，就是系统发送给用户的被点赞，被关注这一类的系统消息，然后持久化到数据库中保存。</p>
<h3 id="私信"><a href="#私信" class="headerlink" title="私信"></a>私信</h3><p>私信有个message表，表中有以下字段：id, from_id, to_id, conversion_id, content, status, create_time</p>
<p>from_id：112，to_id：111，则conversion_id就是111_112，不管谁发给谁，id小的在前面</p>
<p>from_id为1表示系统通知</p>
<h3 id="Spring-aop记录日志"><a href="#Spring-aop记录日志" class="headerlink" title="Spring aop记录日志"></a>Spring aop记录日志</h3><p>aop实现对service层所有的业务方法记录日志</p>
<p>使用前置通知</p>
<p>@Aspect 标记ServiceLogAspect为切面类</p>
<p>@Pointcut标记service的所有方法</p>
<p>@Before表示在所有业务层方法直接执行前置通知</p>
<h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p>使用Redis实现点赞功能</p>
<ul>
<li>支持对帖子、评论点赞</li>
<li>第一次点赞，第2次取消点赞(判断userId在不在set集合中，就可以判断用户有否点过赞，如果已经点过赞了，就将用户从集合中删除)</li>
</ul>
<h3 id="关注"><a href="#关注" class="headerlink" title="关注"></a>关注</h3><p>使用Redis实现了每一个用户的粉丝列表，以及每一个用户的关注列表。</p>
<p>Redis zset实现共同关注 ：取交集 ： sinter myset2 myset3</p>
<p>使用zset以当前时间作为分数排序</p>
<h3 id="引入Spring-Security"><a href="#引入Spring-Security" class="headerlink" title="引入Spring Security"></a>引入Spring Security</h3><p>Spring Security是一个专注与为Java应用程序提供身份认证和授权的框架。</p>
<p>防止CSRF攻击，跨站请求仿造：</p>
<ul>
<li>CSRF攻击：某网站盗取你的Cookie（ticket）凭证，模拟你的身份访问服务器。（发生在提交表单的时候）</li>
<li>Security会在表单里增加一个TOCKEN(自动生成)</li>
<li>基于 CSRF 的工作流程，进行 CSRF 保护的基本思想就是为系统中的每一个连接请求加上一个随机值，我们称之为 csrf_token。这样，当用户向网站 A 发送请求时，网站 A 在生成的 Cookie 中就会设置一个 csrf_token 值。而在浏览器发送请求时，提交的表单数据中也有一个隐藏的 csrf_token 值，这样网站 A 接收到请求后，一方面从 Cookie 中提取出 csrf_token，另一方面也从表单提交的数据中获取隐藏的 csrf_token，将两者进行比对，如果不一致就代表这就是一个伪造的请求。</li>
</ul>
<h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/weixin_41927235/article/details/104070082">牛客高级项目课之牛客讨论区——项目总结_牛客论坛技术文档-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_35484331/article/details/125042339">仿牛客社区项目描述_仿牛客网论坛项目简历-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_48610702/article/details/115859656">Java牛客网社区项目——知识点&amp;面试题_牛客论坛项目 面试-CSDN博客</a></p>
<p><a href="https://www.cnblogs.com/nevererror/category/2152293.html">仿牛客网社区项目 - 随笔分类 - 卷皇 - 博客园 (cnblogs.com)</a></p>
<h2 id="黑马点评"><a href="#黑马点评" class="headerlink" title="黑马点评"></a>黑马点评</h2><h3 id="项目中哪些场景使用了redis？"><a href="#项目中哪些场景使用了redis？" class="headerlink" title="项目中哪些场景使用了redis？"></a>项目中哪些场景使用了redis？</h3><p><img src="/2024/03/24/%E6%8B%BF%E4%B8%8B%E9%A1%B9%E7%9B%AE/image-20240329150443387.png" alt="image-20240329150443387"></p>
<h3 id="乐观锁解决超卖问题"><a href="#乐观锁解决超卖问题" class="headerlink" title="乐观锁解决超卖问题"></a>乐观锁解决超卖问题</h3><p>扣减库存是和之前查询到的库存是一样的，就是说没人在中间修改过库存，这种情况下就可以修改，但是这样效率比较低，很多人同时下单的话就会有很多自旋，所以判断条件就改成如果扣减库存时，库存大于0就扣减。</p>
<h3 id="分布式锁解决一人一单问题"><a href="#分布式锁解决一人一单问题" class="headerlink" title="分布式锁解决一人一单问题"></a>分布式锁解决一人一单问题</h3><p>核心思路：</p>
<p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可。</p>
<h3 id="秒杀优化-异步秒杀思路"><a href="#秒杀优化-异步秒杀思路" class="headerlink" title="秒杀优化-异步秒杀思路"></a>秒杀优化-异步秒杀思路</h3><p>下单流程</p>
<p>1、查询优惠卷</p>
<p>2、判断秒杀库存是否足够</p>
<p>3、查询订单</p>
<p>4、校验是否是一人一单</p>
<p>5、扣减库存</p>
<p>6、创建订单</p>
<p>我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作</p>
<ul>
<li><p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</p>
</li>
<li><p>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</p>
</li>
<li><p>如果抢购成功，将优惠券id和用户id封装后存入消息队列</p>
</li>
<li><p>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</p>
</li>
</ul>
]]></content>
      <categories>
        <category>秋招</category>
      </categories>
  </entry>
  <entry>
    <title>新建文章模板修改</title>
    <url>/2024/01/22/%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0%E6%A8%A1%E6%9D%BF%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<p>使用hexo new命令新建文章时，会生成出来一个模板，下面是对模板进行修改的操作</p>
<span id="more"></span>

<p>命令：<code>hexo new [layout] title</code>或 <code>hexo n [layout] title</code></p>
<p>创建文章前要先选定模板，在hexo中也叫做布局。hexo支持三种布局（layout）：post(默认)、draft、page</p>
<p>如何自定义布局呢？实际上，布局是一个markdown文件，它们保存在<code>scaffolds/</code>目录下，可以看到hexo自带的三种布局其实就是三个<code>.md</code>文件，每一个文件中的内容实际只包含一个Front-matter。可以在这里修改布局或者建立新的布局，然后创建文章时使用这些布局。</p>
<p><strong>在hexo的配置文件中可以修改新建文章时默认使用的主题，位置如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br></pre></td></tr></table></figure>



<p>参考文章：</p>
<p><a href="https://zhuanlan.zhihu.com/p/132823826">使用hexo新建、编辑并预览文章 - 知乎 (zhihu.com)</a></p>
<p><a href="https://hexo.io/docs/configuration#Writing">配置 |Hexo的</a></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>测试二级分类</title>
    <url>/2024/05/12/%E6%B5%8B%E8%AF%95%E4%BA%8C%E7%BA%A7%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<hr>
<p>redis相关知识</p>
<span id="more"></span>

<p>redis</p>
<p>mysql</p>
<p>jvm</p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>添加自定义页面</title>
    <url>/2024/01/23/%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<p>hexo博客添加自定义html页面</p>
<span id="more"></span>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>以前收集了很多有趣的html特效文件，自己也写过不少，但是这些文件都有一个缺点：只能本地浏览。</p>
<p>很早以前就有一个想法，就是将这些文件部署到网站上供人们随时随地浏览，只是一直没能实现。现在有了自己的博客，正好实现完成这个想法。</p>
<h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>1.首先在博客根目录的source文件夹下，新建一个文件夹用于存放要部署的HTML文件：</p>
<p>我这里建了一个叫HTML的文件夹，里面的子文件夹可以存放各个HTML文件，当然也可以只创建一个主文件夹，直接在里面放HTML文件。</p>
<p>2.然后在博客根目录的配置文件_config.yml文件里，设置跳过渲染：</p>
<p>单个文件，就写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 跳过渲染</span><br><span class="line">skip_render: </span><br><span class="line">  - &quot;xxxx.html&quot;</span><br></pre></td></tr></table></figure>

<p>整个文件夹，就写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 跳过文件夹下所有子文件夹和文件</span><br><span class="line">skip_render: </span><br><span class="line">  - &quot;文件夹名/**&quot;   </span><br></pre></td></tr></table></figure>

<p>因为hexo部署的是静态文件，所有文章的md文件会被渲染成html文件，<br>hexo会帮我们把所有css、js文件都加到文章里，我们之前跳过了渲染，所以就需要手动把css、js整合到html文件里</p>
<p>一般我们的代码就是这种结构：</p>
<p>下面处理分两部分：</p>
<p>css：找到index.html文件里的语句,如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/xxx.css&quot;&gt;    </span><br></pre></td></tr></table></figure>

<p>然后在css文件夹中找到对应的文件xxx.css，复制文件内容，把上面的代码改为：</p>
 <style> css代码内容 </style>
<p>js：找到index.html文件里的语句，如：</p>
<script src="js/xxx.js"></script>
<p>然后在js文件夹中找到对应的文件xxx.js，复制文件内容，把上面的代码改为：</p>
<script> js代码内容 </script>
<p>4.检验成果</p>
<p>hexo clean<br>hexo g<br>hexo d<br>部署后来到<a href="https://xxxxx.github.io/%E5%AD%98%E6%94%BEhtml%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9/xxx.html">https://xxxxx.github.io/存放html文件的文件夹/xxx.html</a></p>
<p>即可查看到你的自定义html页面了！</p>
<p>建议在部署前先试试在本地能否打开，如果不行再按上文修改一次。</p>
<h3 id="其他的优化"><a href="#其他的优化" class="headerlink" title="其他的优化"></a>其他的优化</h3><p>如果想将这些html的界面放到导航菜单栏上，修改主题配置文件_config.butterfly.yml对应的导航菜单栏代码即可，这里将我的代码放出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">   主页: / || fas fa-home</span><br><span class="line">   时间轴: /archives/ || fas fa-archive</span><br><span class="line">   标签: /tags/ || fas fa-tags</span><br><span class="line">   分类: /categories/ || fas fa-folder-open</span><br><span class="line">   Demo||fas fa-file-code:</span><br><span class="line">     - all html demo || /Demo/ || far fa-file-code</span><br><span class="line">     - 圈小猫 || /HTML/圈小猫.html || fas fa-code</span><br><span class="line">     - 撕渔网 || /HTML/撕渔网.html || fas fa-code</span><br><span class="line">     - 纸飞机 || /HTML/纸飞机.html || fas fa-code</span><br><span class="line">     - 彩虹雨 || /HTML/彩虹雨.html || fas fa-code</span><br><span class="line">     - 方块穿梭 || /HTML/方块穿梭.html || fas fa-code</span><br><span class="line">     - 碰撞小球 || /HTML/碰撞小球.html || fas fa-code</span><br><span class="line">     - 烟花效果 || /HTML/烟花效果.html || fas fa-code</span><br><span class="line">     - 骇客帝国 || /HTML/骇客帝国.html || fas fa-code</span><br><span class="line">   娱乐||fas fa-list:</span><br><span class="line">     - 音乐 || /music/ || fas fa-music</span><br><span class="line">     - 电影 || /movies/ || fas fa-video</span><br><span class="line">   友链: /link/ || fas fa-link</span><br><span class="line">   关于: /about/ || fas fa-heart</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/weixin_58068682/article/details/116611715">Hexo博客技巧：添加自定义html页面_hexo里html-CSDN博客</a></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>草稿</title>
    <url>/2024/01/22/%E8%8D%89%E7%A8%BF/</url>
    <content><![CDATA[<p>使用<code>hexo n draft draft1</code>命令将在<code>source\</code>目录下创建<code>_drafts</code>目录，并生成一个<code>draft1.md</code>文件。</p>
<p>当你编辑完草稿后，可以把文章推送到<code>_posts</code>目录下，通过下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo publish &lt;file_name&gt;</span><br></pre></td></tr></table></figure>

<p>可以使用<code>hexo --draft</code>命令可以查看已有草稿。</p>
<p>想要在本地预览草稿的静态文件，也需要在生成静态文件时加上<code>draft</code>参数。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>hexo提交github出错</title>
    <url>/2024/01/18/%E8%A7%A3%E5%86%B3github%E6%8F%90%E4%BA%A4%E5%87%BA%E9%94%99/</url>
    <content><![CDATA[<p>提交github报错问题</p>
<span id="more"></span>





<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/636418854">解决 Github port 443 : Timed out - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/qq_59039063/article/details/132459418">解决使用Hexo搭建个人博客遇到的一些问题_hexo总连不上github-CSDN博客</a></p>
<p>一般这种情况大多是网络原因导致的，科学上网工具不稳定，DNS解析被污染等因素。我们可以详细看看建立 ssh 连接的过程中发生了什么，可以使用 ssh -v命令，-v表示 verbose，会打出详细日志。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -vT git@github.com</span><br></pre></td></tr></table></figure>



<p>问题描述：</p>
<p>使用<code>hexo d</code>命令推送博客到github时出现错误</p>
<p><img src="/2024/01/18/%E8%A7%A3%E5%86%B3github%E6%8F%90%E4%BA%A4%E5%87%BA%E9%94%99/image-20240118091111539.png" alt="image-20240118091111539"></p>
<p>分析：</p>
<p>git所设端口与系统代理不一致</p>
<p>解决方法：</p>
<ol>
<li><p>记录下当前系统代理的 IP 地址和端口号</p>
<p>地址与端口号为：127.0.0.1:7890</p>
</li>
<li><p>修改git的网络设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意修改成自己的IP和端口号</span></span><br><span class="line">git config --global http.proxy http://127.0.0.1:7890 </span><br><span class="line">git config --global https.proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure></li>
</ol>
<p><em>Tip：主要解决的是为啥搭建了梯子依旧不好使的问题</em></p>
<p>后记：</p>
<p>当我们访问GitHub的时候一般都会使用梯子，所以往上推代码的时候也是需要梯子，没有梯子推送成功概率很低，一般都会报错超时，所以设置梯子提高访问成功率；</p>
<p>取消代理是因为，访问 Gitee 或其它是不需要梯子，所以要取消代理；或者后悔设置代理了，也可以利用此取消</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取消代理</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看代理</span></span><br><span class="line">git config --global --get http.proxy</span><br><span class="line">git config --global --get https.proxy</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>请求从前端到后端的过程</title>
    <url>/2024/03/14/%E8%AF%B7%E6%B1%82%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<hr>
<p>请求从前端到后端的过程(概述)</p>
<span id="more"></span>

<p>浏览器发一个请求(前提:前后端分离)) 项目 ,普通的请求直接返回html,css静态页面 ,ajax异步请求的话到达nginx, nginx通过反向代理再找tomcat通过NIO(多路复用器) 分配一个线程池里的线程接这个请求, →过滤器(tomcat) →拦截器(spring) 然后到达SpringMVC 匹配controller service dao  通过ORM框架 连接数据库获取数据.</p>
<p><a href="https://blog.csdn.net/2301_78958943/article/details/135129400?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-135129400-blog-89813160.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-135129400-blog-89813160.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=2">请求从前端到后端的过程(概述)_前端发送请求到后端全过程-CSDN博客</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>集和类常见接口和实现类</title>
    <url>/2024/02/02/%E9%9B%86%E5%92%8C%E7%B1%BB%E5%B8%B8%E8%A7%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB/</url>
    <content><![CDATA[<hr>
<p>Java集合类常见接口及实现类汇总</p>
<span id="more"></span>

<h2 id="集和框架概述"><a href="#集和框架概述" class="headerlink" title="集和框架概述"></a>集和框架概述</h2><p>所有集合类都位于java.util包下，但支持多线程的集合类位于java.util.concurrent包下。</p>
<p>Java集合类主要由两个根接口Collection和Map派生出来的，Collection派生出了三个子接口：List、Set、Queue，因此Java集合大致也可分成List、Set、Queue、Map四种接口体系，（注意：Map不是Collection的子接口）。其中List代表了有序可重复集合，可直接根据元素的索引来访问；Set代表无序不可重复集合，只能根据元素本身来访问；Queue是队列集合；Map代表的是存储key-value对的集合，可根据元素的key来访问value。</p>
<p>常见的实现类分别是ArrayList、LinkedList、ArrayQueue、HashSet、TreeSet、HashMap、TreeMap等。</p>
<p><img src="/2024/02/02/%E9%9B%86%E5%92%8C%E7%B1%BB%E5%B8%B8%E8%A7%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB/center.png" alt="在这里插入图片描述"></p>
<h2 id="常用集和接口"><a href="#常用集和接口" class="headerlink" title="常用集和接口"></a>常用集和接口</h2><p><img src="/2024/02/02/%E9%9B%86%E5%92%8C%E7%B1%BB%E5%B8%B8%E8%A7%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB/w3.png" alt="在这里插入图片描述"></p>
<p><img src="/2024/02/02/%E9%9B%86%E5%92%8C%E7%B1%BB%E5%B8%B8%E8%A7%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB/v2-02315d96094ad52616c6c44c01e7d319_720w.webp" alt="img"></p>
<h3 id="Collection的常用方法"><a href="#Collection的常用方法" class="headerlink" title="Collection的常用方法"></a>Collection的常用方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean add(E e) - 用于将元素e放入当前集合中。</span><br><span class="line">boolean addAll(Collection&lt;? extends E&gt; c) </span><br><span class="line">- 用于将参数指定集合中的所有元素放入当前集合中。</span><br><span class="line">boolean remove(Object o) </span><br><span class="line">- 用于从当前集合中删除参数指定的元素。</span><br><span class="line">boolean removeAll(Collection&lt;?&gt; c) </span><br><span class="line">- 用于从当前集合中删除参数指定集合中的所有元素。</span><br><span class="line">void clear() </span><br><span class="line">- 用于将当前集合中的所有元素移除。</span><br><span class="line">boolean contains(Object o) </span><br><span class="line">- 用于判断当前集合中是否包含参数指定的单个元素。</span><br><span class="line">- (o==null ? e==null : o.equals(e)) </span><br><span class="line">boolean containsAll(Collection&lt;?&gt; c) </span><br><span class="line">- 用于判断当前集合中是否包含参数指定集合中的所有元素。</span><br><span class="line">boolean isEmpty() - 用于判断当前集合是否为空。</span><br><span class="line">int size() - 用于返回当前集合中元素的个数。</span><br><span class="line">boolean retainAll(Collection&lt;?&gt; c) </span><br><span class="line">- 用于获取当前集合和参数集合的交集并保留到当前集合中。</span><br><span class="line">- 若当前集合中的内容发生了更改则返回true，否则返回false。</span><br></pre></td></tr></table></figure>

<h3 id="List常用方法"><a href="#List常用方法" class="headerlink" title="List常用方法"></a>List常用方法</h3><p><img src="/2024/02/02/%E9%9B%86%E5%92%8C%E7%B1%BB%E5%B8%B8%E8%A7%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB/v2-89cebb489a429b2e6f2fc303505ea30d_r.jpg" alt="img"></p>
<p>java.util.List接口是Collection接口的子接口，元素有先后放入次序，并且允许重复。<br>该接口的主要实现类有：ArrayList类、LinkedList类、Stack类以及Vector类。<br>其中ArrayList类的底层是采用动态数组实现的，因此增删不方便，访问元素方便；<br>其中LinkedList类的底层是采用链表实现的，因此增删方便，访问元素不方便；<br>其中Stack(栈)类的底层是采用动态数组实现的，用于描述一种具有后进先出特性的数据结构，简称为LIFO(last in first out)。<br>其中Vector类的底层是采用动态数组实现的，与ArrayList类相比属于早期的类，属于线程安全的类，因此效率比较低，推荐使用ArrayList类取代之。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void add(int index, E element) </span><br><span class="line">- 用于将元素element插入到当前集合中index指向的位置。</span><br><span class="line">boolean addAll(int index, Collection&lt;? extends E&gt; c) </span><br><span class="line">- 用于将集合c中所有元素插入到当前集合中index指向的位置。</span><br><span class="line">E remove(int index) </span><br><span class="line">- 用于将index位置的元素从当前集合移除。</span><br><span class="line">- 返回被删除的元素值，下标不合理时会产生下标越界异常。</span><br><span class="line">E set(int index, E element) </span><br><span class="line">- 使用element元素替换当前集合中index位置的元素，返回被替换的元素。</span><br><span class="line">E get(int index) </span><br><span class="line">- 用于返回当前集合中下标为index位置的元素。</span><br><span class="line">List&lt;E&gt; subList(int fromIndex, int toIndex) </span><br><span class="line">- 用于返回当前集合中从fromIndex(包含)到toIndex(不包含)之间的部分视图。</span><br><span class="line">- 返回的集合和当前集合共用同一块内存区域。</span><br></pre></td></tr></table></figure>

<h3 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h3><p><strong>Queue接口</strong>是<strong>Collection接口</strong>的子接口，与<strong>List接口是平级关系</strong>。该接口主要描述具有<strong>先进先出特性</strong>的数据结构，简称为FIFO(first in first out)，叫队列。该接口的主要实现类是LinkedList类，因为该类在增删方面有一定的优势。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean offer(E e) - 将参数指定的元素e插入到当前队列的末尾。</span><br><span class="line">- 若插入成功则返回true，否则返回false。</span><br><span class="line">E poll() - 用于从当前队列的队首移除一个元素并返回。</span><br><span class="line">- 若当前队列为空，则返回null。</span><br><span class="line">E peek() - 用于获取当前队列的队首元素并返回。</span><br><span class="line">- 若当前队列为空，则返回null。</span><br></pre></td></tr></table></figure>

<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>java.util.Set接口是Collection接口的子接口，元素没有先后放入次序，并且不允许重复；该接口的主要实现类有：HashSet类 和 TreeSet类。其中HashSet类的底层是采用哈希表进行数据管理的，TreeSet类的底层是采用二叉树（红黑树）进行数据管理的。</p>
<ul>
<li><p>元素放入HashSet类的过程</p>
<p>   (1)使用元素调用hashCode()方法，获取该元素的哈希码值；<br>   (2)将哈希码值交给哈希算法来生成哈希表中的索引位置；<br>   (3)若该位置没有元素，则将该元素直接放入该位置即可；<br>   (4)若该位置有元素，则判断该元素是否与已有元素相等；<br>   (5)若相等，则放弃新元素的插入，保留旧元素来确保元素不能重复；<br>   (6)若不相等，则将新元素插入到该元素的后面，若后面有元素则继续比较；</p>
</li>
</ul>
<p><strong>TreeSet类</strong>是java.util.Set接口的实现类，底层是一棵有序二叉树。</p>
<p>为了使得插入新元素后该集合的底层依然是有序二叉树，则需要<strong>指定元素比较大小的规则</strong>，而具体的执行方式有两种：</p>
<ul>
<li><strong>使用元素的自然排序规则来处理，让元素类型实现java.lang.Comparable接口并重写方法</strong></li>
<li><strong>使用创建集合时的比较器来指定规则，传入java.util.Comparator接口的引用作为实参</strong></li>
</ul>
<p>该接口的常用方法参考Collection接口即可。</p>
<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p><img src="/2024/02/02/%E9%9B%86%E5%92%8C%E7%B1%BB%E5%B8%B8%E8%A7%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB/v2-a6a84ee86170bec483c91b1e6d748e30_r.jpg" alt="img"></p>
<p>java.util.Map&lt;K,V&gt;接口主要用于存放一对一对元素，分别叫做key(键)和value(值)。key是不允许重复的，而且每个key对应唯一的value。该接口的主要实现类有：HashMap类 和 TreeMap类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">V put(K key, V value) - 用于将参数指定的key和value组成一对放入当前集合中。</span><br><span class="line">- 增加key和value时则返回null，修改key和value时则返回key之前对应的value。</span><br><span class="line">V remove(Object key) - 用于从当前集合删除key关联的键值对。</span><br><span class="line">- 若key不存在则返回null，否则返回key对应的value。</span><br><span class="line">boolean containsKey(Object key) </span><br><span class="line">- 用于判断当前集合中是否存在参数指定的key。</span><br><span class="line">boolean containsValue(Object value) </span><br><span class="line">- 用于判断当前集合中是否包含参数指定的value。</span><br><span class="line">V get(Object key) </span><br><span class="line">- 用于根据参数指定的key来返回对应的value。</span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() </span><br><span class="line">- 用于返回当前集合中包含映射关系的Set视图，通俗来说，就是把Map转换为Set。</span><br><span class="line">Set&lt;K&gt; keySet() </span><br><span class="line">- 用于返回当前集合中包含key的Set视图。</span><br><span class="line">java.util.Map.Entry&lt;K,V&gt;接口代表键值对，提供的方法有：</span><br><span class="line">K getKey() - 用于获取当前键值对中key的数值并返回。</span><br><span class="line">V getValue() - 用于获取当前键值对中value的数值并返回。</span><br></pre></td></tr></table></figure>

<h2 id="栈和队列相关"><a href="#栈和队列相关" class="headerlink" title="栈和队列相关"></a>栈和队列相关</h2><p><img src="/2024/02/02/%E9%9B%86%E5%92%8C%E7%B1%BB%E5%B8%B8%E8%A7%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDEzNjI5,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>Vector不行是因为效率不太行，很多方法都用了synchronized修饰，虽然线程安全，但是像ArrayDeque,LinkedList这些线程不安全的，在需要安全的时候也可以用Collections.synchronizedCollection()转化成线程安全的，所以Vector就没什么用处了。</p>
<p><strong>Deque常用方法：</strong></p>
<p><strong>把Deque当栈用的时候：</strong><br>入栈			push(E e)<br>出栈			poll() &#x2F; pop() 后者在栈空的时候会抛出异常，前者返回null<br>查看栈顶	peek() 为空时返回null<br><strong>把Deque当队列用的时候：</strong><br>入队			offer(E e)<br>出队			poll() 为空时返回null<br>查看队首	peek() 为空时返回null</p>
<p>有些时候需要进行一些骚操作的时候（比如取得栈底元素，取得队尾元素），这些常规操作就不能满足了。<br><strong>下面就是Deque中一些更详细的方法：</strong></p>
<p><strong>从上面(头部)插入：</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void addFirst(E e)</td>
<td>将指定的元素插入此双端队列的前面 ，空间不足抛异常</td>
</tr>
<tr>
<td>boolean offerFirst(E e)</td>
<td>将指定的元素插入此双端队列的前面 ，空间不足插入失败返回回false</td>
</tr>
<tr>
<td>void push(E e)</td>
<td>将指定的元素插入此双端队列的前面 ，空间不足抛异常</td>
</tr>
</tbody></table>
<p><strong>从上面(头部)出来&#x2F;观察:</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>E removeFirst()</td>
<td>检索并删除第一个元素，为空时抛出异常</td>
</tr>
<tr>
<td>E remove()</td>
<td>和removeFirst一样 检索并删除第一个元素，为空时抛出异常</td>
</tr>
<tr>
<td>E pop()</td>
<td>和removeFirst一样 检索并删除第一个元素，为空时抛出异常</td>
</tr>
<tr>
<td>E pollFirst()</td>
<td>检索并删除第一个元素 ，为空时返回null</td>
</tr>
<tr>
<td>E poll()</td>
<td>和pollFirst一样 检索并删除第一个元素 ，为空时返回null</td>
</tr>
<tr>
<td>E getFirst()</td>
<td>只看看第一个元素 ，不出来，为空就抛异常</td>
</tr>
<tr>
<td>E element()</td>
<td>和getFirst一样 只看看第一个元素 ，不出来，为空就抛异常</td>
</tr>
<tr>
<td>E peekFirst()</td>
<td>只看看第一个元素 ，不出来，为空时返回null</td>
</tr>
<tr>
<td>E peek()</td>
<td>和peekFirst一样 只看看第一个元素 ，不出来，为空时返回null</td>
</tr>
</tbody></table>
<p><strong>从下面(尾部)插入：</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void addLast(E e)</td>
<td>将指定的元素插入此双端队列的后面 ，空间不足抛异常</td>
</tr>
<tr>
<td>boolean offerLast(E e)</td>
<td>将指定的元素插入此双端队列的后面，空间不足返回false</td>
</tr>
<tr>
<td>boolean add(E e)</td>
<td>将指定的元素插入此双端队列的后面，空间不足抛异常</td>
</tr>
<tr>
<td>boolean offer(E e)</td>
<td>将指定的元素插入此双端队列的后面，空间不足返回false</td>
</tr>
</tbody></table>
<p><strong>从下面(尾部)出来&#x2F;观察:</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>E removeLast()</td>
<td>检索并删除最后一个元素，为空时抛出异常</td>
</tr>
<tr>
<td>E pollLast()</td>
<td>检索并删除最后一个元素 ，为空时返回null</td>
</tr>
<tr>
<td>E getLast()</td>
<td>只看看最后一个元素 ，不出来，为空就抛异常</td>
</tr>
<tr>
<td>E peekLast()</td>
<td>只看看最后一个元素 ，不出来，为空时返回null</td>
</tr>
</tbody></table>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zhuanlan.zhihu.com/p/165914686">详解java集合，Collection，list，set，map汇总 - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/qq_44013629/article/details/106461200">JAVA 栈，为什么要使用Deque，而不推荐使用Stack，Deque中ArrayDeque与LinkedList的区别，Deque方法详解_java 栈为什么用deque-CSDN博客</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
</search>
